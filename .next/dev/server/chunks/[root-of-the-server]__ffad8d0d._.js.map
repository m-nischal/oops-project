{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 22, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/untitled%20folder/src/lib/dbConnect.js"],"sourcesContent":["// lib/dbConnect.js\nimport mongoose from \"mongoose\";\n\n/**\n * @file dbConnect\n * @brief Reusable MongoDB connection util for Next.js API routes.\n *\n * Throws if MONGO_URI missing. Caches connection in global to avoid multiple\n * connections during hot-reload/development.\n */\n\nconst MONGO_URI = process.env.MONGO_URI;\nif (!MONGO_URI) throw new Error(\"MONGO_URI not set\");\n\nlet cached = global._mongoose || { conn: null, promise: null };\nif (!global._mongoose) global._mongoose = cached;\n\n/**\n * Ensure there is a single mongoose connection used across calls.\n * @returns {Promise<mongoose.Mongoose>}\n */\nexport default async function dbConnect() {\n  if (cached.conn) return cached.conn;\n  if (!cached.promise) {\n    // Use the connection string directly; options are managed by mongoose v8 defaults.\n    cached.promise = mongoose.connect(MONGO_URI).then(m => m);\n  }\n  cached.conn = await cached.promise;\n  return cached.conn;\n}\n"],"names":[],"mappings":"AAAA,mBAAmB;;;;;AACnB;;AAEA;;;;;;CAMC,GAED,MAAM,YAAY,QAAQ,GAAG,CAAC,SAAS;AACvC,IAAI,CAAC,WAAW,MAAM,IAAI,MAAM;AAEhC,IAAI,SAAS,yDAAO,SAAS,IAAI;IAAE,MAAM;IAAM,SAAS;AAAK;AAC7D,IAAI,CAAC,yDAAO,SAAS,EAAE,yDAAO,SAAS,GAAG;AAM3B,eAAe;IAC5B,IAAI,OAAO,IAAI,EAAE,OAAO,OAAO,IAAI;IACnC,IAAI,CAAC,OAAO,OAAO,EAAE;QACnB,mFAAmF;QACnF,OAAO,OAAO,GAAG,oHAAQ,CAAC,OAAO,CAAC,WAAW,IAAI,CAAC,CAAA,IAAK;IACzD;IACA,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;IAClC,OAAO,OAAO,IAAI;AACpB","debugId":null}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/untitled%20folder/src/models/orderModel.js"],"sourcesContent":["// models/orderModel.js\nimport mongoose from \"mongoose\";\n\nconst { Schema } = mongoose;\n\n/**\n * Minimal snapshot item schema used inside Order documents.\n * We intentionally store product name and unitPrice as snapshot values\n * to preserve historical pricing even if product changes later.\n */\nconst orderItemSchema = new Schema({\n  productId: { type: Schema.Types.ObjectId, ref: \"Product\", required: true },\n  name: { type: String, required: true },\n  sizeLabel: { type: String, required: true },\n  qty: { type: Number, required: true, min: 1 },\n  unitPrice: { type: Number, required: true },\n  subtotal: { type: Number, required: true },\n}, { _id: false });\n\nconst orderSchema = new Schema({\n  customer: {\n    name: { type: String, required: true },\n    email: { type: String },\n    phone: { type: String },\n    address: { type: String },\n  },\n  items: { type: [orderItemSchema], required: true },\n\n  subtotal: { type: Number, required: true },\n  shipping: { type: Number, default: 0 },\n  tax: { type: Number, default: 0 },\n  discount: { type: Number, default: 0 },\n  total: { type: Number, required: true },\n\n  status: {\n    type: String,\n    enum: [\"created\",\"pending\",\"paid\",\"processing\",\"shipped\",\"delivered\",\"cancelled\",\"refunded\"],\n    default: \"created\"\n  },\n\n  payment: {\n    provider: { type: String },\n    paymentId: { type: String },\n    method: { type: String },\n    paidAt: { type: Date }\n  },\n\n  fulfillment: {\n    trackingNumber: String,\n    carrier: String,\n    shippedAt: Date,\n    deliveredAt: Date\n  },\n\n  userId: { type: Schema.Types.ObjectId, ref: \"User\" },\n  meta: { type: Schema.Types.Mixed },\n  archived: { type: Boolean, default: false }\n}, { timestamps: true });\n\n// Useful indexes for listing and filtering orders\norderSchema.index({ userId: 1, createdAt: -1 });\norderSchema.index({ \"customer.email\": 1 });\norderSchema.index({ status: 1, createdAt: -1 });\n\nexport default mongoose.models.Order || mongoose.model(\"Order\", orderSchema);\n"],"names":[],"mappings":"AAAA,uBAAuB;;;;;AACvB;;AAEA,MAAM,EAAE,MAAM,EAAE,GAAG,oHAAQ;AAE3B;;;;CAIC,GACD,MAAM,kBAAkB,IAAI,OAAO;IACjC,WAAW;QAAE,MAAM,OAAO,KAAK,CAAC,QAAQ;QAAE,KAAK;QAAW,UAAU;IAAK;IACzE,MAAM;QAAE,MAAM;QAAQ,UAAU;IAAK;IACrC,WAAW;QAAE,MAAM;QAAQ,UAAU;IAAK;IAC1C,KAAK;QAAE,MAAM;QAAQ,UAAU;QAAM,KAAK;IAAE;IAC5C,WAAW;QAAE,MAAM;QAAQ,UAAU;IAAK;IAC1C,UAAU;QAAE,MAAM;QAAQ,UAAU;IAAK;AAC3C,GAAG;IAAE,KAAK;AAAM;AAEhB,MAAM,cAAc,IAAI,OAAO;IAC7B,UAAU;QACR,MAAM;YAAE,MAAM;YAAQ,UAAU;QAAK;QACrC,OAAO;YAAE,MAAM;QAAO;QACtB,OAAO;YAAE,MAAM;QAAO;QACtB,SAAS;YAAE,MAAM;QAAO;IAC1B;IACA,OAAO;QAAE,MAAM;YAAC;SAAgB;QAAE,UAAU;IAAK;IAEjD,UAAU;QAAE,MAAM;QAAQ,UAAU;IAAK;IACzC,UAAU;QAAE,MAAM;QAAQ,SAAS;IAAE;IACrC,KAAK;QAAE,MAAM;QAAQ,SAAS;IAAE;IAChC,UAAU;QAAE,MAAM;QAAQ,SAAS;IAAE;IACrC,OAAO;QAAE,MAAM;QAAQ,UAAU;IAAK;IAEtC,QAAQ;QACN,MAAM;QACN,MAAM;YAAC;YAAU;YAAU;YAAO;YAAa;YAAU;YAAY;YAAY;SAAW;QAC5F,SAAS;IACX;IAEA,SAAS;QACP,UAAU;YAAE,MAAM;QAAO;QACzB,WAAW;YAAE,MAAM;QAAO;QAC1B,QAAQ;YAAE,MAAM;QAAO;QACvB,QAAQ;YAAE,MAAM;QAAK;IACvB;IAEA,aAAa;QACX,gBAAgB;QAChB,SAAS;QACT,WAAW;QACX,aAAa;IACf;IAEA,QAAQ;QAAE,MAAM,OAAO,KAAK,CAAC,QAAQ;QAAE,KAAK;IAAO;IACnD,MAAM;QAAE,MAAM,OAAO,KAAK,CAAC,KAAK;IAAC;IACjC,UAAU;QAAE,MAAM;QAAS,SAAS;IAAM;AAC5C,GAAG;IAAE,YAAY;AAAK;AAEtB,kDAAkD;AAClD,YAAY,KAAK,CAAC;IAAE,QAAQ;IAAG,WAAW,CAAC;AAAE;AAC7C,YAAY,KAAK,CAAC;IAAE,kBAAkB;AAAE;AACxC,YAAY,KAAK,CAAC;IAAE,QAAQ;IAAG,WAAW,CAAC;AAAE;uCAE9B,oHAAQ,CAAC,MAAM,CAAC,KAAK,IAAI,oHAAQ,CAAC,KAAK,CAAC,SAAS","debugId":null}},
    {"offset": {"line": 204, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/untitled%20folder/src/models/productModel.js"],"sourcesContent":["// models/productModel.js\nimport mongoose from \"mongoose\";\n\nconst sizeSchema = new mongoose.Schema({\n  label: { type: String, required: true },\n  stock: { type: Number, default: 0 },\n}, { _id: false });\n\nconst ratingSchema = new mongoose.Schema({\n  avg: { type: Number, default: 0 },\n  count: { type: Number, default: 0 },\n}, { _id: false });\n\n/**\n * Product schema - stores snapshot of product data and size-level stock.\n * Use integer currency values (e.g., rupees or paisa) consistently across the app.\n */\nconst productSchema = new mongoose.Schema({\n  name: { type: String, required: true },\n  price: { type: Number, required: true },\n  originalPrice: { type: Number, default: 0 },\n  description: { type: String, default: \"\" },\n  materials: { type: [String], default: [] },\n  images: { type: [String], default: [] },\n  sizes: { type: [sizeSchema], default: [] },\n  rating: { type: ratingSchema, default: () => ({}) },\n  category: { type: String, default: \"General\" }\n}, { timestamps: true });\n\n// Text index for full-text search on name and description\nproductSchema.index({ name: \"text\", description: \"text\" });\n\n// Prevent model overwrite in dev/hot-reload environments (Next.js etc.)\nconst Product = mongoose.models.Product || mongoose.model(\"Product\", productSchema);\n\nexport default Product;\n"],"names":[],"mappings":"AAAA,yBAAyB;;;;;AACzB;;AAEA,MAAM,aAAa,IAAI,oHAAQ,CAAC,MAAM,CAAC;IACrC,OAAO;QAAE,MAAM;QAAQ,UAAU;IAAK;IACtC,OAAO;QAAE,MAAM;QAAQ,SAAS;IAAE;AACpC,GAAG;IAAE,KAAK;AAAM;AAEhB,MAAM,eAAe,IAAI,oHAAQ,CAAC,MAAM,CAAC;IACvC,KAAK;QAAE,MAAM;QAAQ,SAAS;IAAE;IAChC,OAAO;QAAE,MAAM;QAAQ,SAAS;IAAE;AACpC,GAAG;IAAE,KAAK;AAAM;AAEhB;;;CAGC,GACD,MAAM,gBAAgB,IAAI,oHAAQ,CAAC,MAAM,CAAC;IACxC,MAAM;QAAE,MAAM;QAAQ,UAAU;IAAK;IACrC,OAAO;QAAE,MAAM;QAAQ,UAAU;IAAK;IACtC,eAAe;QAAE,MAAM;QAAQ,SAAS;IAAE;IAC1C,aAAa;QAAE,MAAM;QAAQ,SAAS;IAAG;IACzC,WAAW;QAAE,MAAM;YAAC;SAAO;QAAE,SAAS,EAAE;IAAC;IACzC,QAAQ;QAAE,MAAM;YAAC;SAAO;QAAE,SAAS,EAAE;IAAC;IACtC,OAAO;QAAE,MAAM;YAAC;SAAW;QAAE,SAAS,EAAE;IAAC;IACzC,QAAQ;QAAE,MAAM;QAAc,SAAS,IAAM,CAAC,CAAC,CAAC;IAAE;IAClD,UAAU;QAAE,MAAM;QAAQ,SAAS;IAAU;AAC/C,GAAG;IAAE,YAAY;AAAK;AAEtB,0DAA0D;AAC1D,cAAc,KAAK,CAAC;IAAE,MAAM;IAAQ,aAAa;AAAO;AAExD,wEAAwE;AACxE,MAAM,UAAU,oHAAQ,CAAC,MAAM,CAAC,OAAO,IAAI,oHAAQ,CAAC,KAAK,CAAC,WAAW;uCAEtD","debugId":null}},
    {"offset": {"line": 296, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/untitled%20folder/src/services/inventory.js"],"sourcesContent":["// src/services/inventory.js\nimport Product from \"models/productModel.js\";\n\n/**\n * @file InventoryService\n * @brief Centralized product stock operations (sizes array).\n *\n * Responsibilities:\n *  - Single-item atomic updates (increaseStock, decreaseStock)\n *  - Multi-item transactional decrement (decreaseStockForItems)\n *  - Safe helpers for adding sizes, checking stock, and total stock\n */\n\n/** Base error for inventory operations */\nclass InventoryError extends Error {}\n/** Thrown when requested qty cannot be satisfied */\nclass InsufficientStockError extends InventoryError {}\n/** Thrown when input params are invalid */\nclass InvalidParamsError extends InventoryError {}\n\nexport default class InventoryService {\n  /**\n   * Normalize size label defensively.\n   * @private\n   * @param {any} sizeLabel\n   * @returns {string}\n   */\n  static _normalizeLabel(sizeLabel) {\n    return sizeLabel === undefined || sizeLabel === null ? \"\" : String(sizeLabel).trim();\n  }\n\n  /**\n   * Validate and normalize params for single-item operations.\n   * Throws InvalidParamsError on invalid input.\n   * @private\n   * @param {String|ObjectId} productId\n   * @param {String} sizeLabel\n   * @param {Number} qty\n   * @returns {{productId:*, sizeLabel:string, qty:number}}\n   */\n  static _validateParams(productId, sizeLabel, qty) {\n    if (!productId) throw new InvalidParamsError(\"productId is required\");\n    const label = this._normalizeLabel(sizeLabel);\n    if (!label) throw new InvalidParamsError(\"sizeLabel is required\");\n    const q = Number(qty);\n    if (!Number.isFinite(q) || q <= 0) throw new InvalidParamsError(\"qty must be a positive number\");\n    return { productId, sizeLabel: label, qty: Math.floor(q) };\n  }\n\n  /**\n   * Decrease stock for a specific product size by qty.\n   * If a mongoose session is provided, the update participates in the transaction.\n   * @param {String|ObjectId} productId\n   * @param {String} sizeLabel\n   * @param {Number} qty\n   * @param {mongoose.ClientSession} [session]\n   * @returns {Promise<boolean>} true if modified, false otherwise\n   * @throws {InvalidParamsError}\n   */\n  static async decreaseStock(productId, sizeLabel, qty, session = null) {\n    const params = this._validateParams(productId, sizeLabel, qty);\n\n    const filter = {\n      _id: params.productId,\n      \"sizes.label\": params.sizeLabel,\n      \"sizes.stock\": { $gte: params.qty }\n    };\n\n    const update = { $inc: { \"sizes.$[el].stock\": -params.qty } };\n    const options = { arrayFilters: [{ \"el.label\": params.sizeLabel }] };\n    if (session) options.session = session;\n\n    const res = await Product.updateOne(filter, update, options);\n    return (res.modifiedCount ?? res.nModified ?? 0) > 0;\n  }\n\n  /**\n   * Increase stock for a specific product size by qty (restock/cancel).\n   * Returns true if an existing size was updated, false if not found (size missing).\n   * Use addOrCreateSize to add a missing size.\n   * @param {String|ObjectId} productId\n   * @param {String} sizeLabel\n   * @param {Number} qty\n   * @param {mongoose.ClientSession} [session]\n   * @returns {Promise<boolean>}\n   */\n  static async increaseStock(productId, sizeLabel, qty, session = null) {\n    const params = this._validateParams(productId, sizeLabel, qty);\n\n    const filter = { _id: params.productId, \"sizes.label\": params.sizeLabel };\n    const update = { $inc: { \"sizes.$[el].stock\": params.qty } };\n    const options = { arrayFilters: [{ \"el.label\": params.sizeLabel }] };\n    if (session) options.session = session;\n\n    const res = await Product.updateOne(filter, update, options);\n    return (res.modifiedCount ?? res.nModified ?? 0) > 0;\n  }\n\n  /**\n   * Add a new size entry if it doesn't exist, or set the stock if it does.\n   * @param {String|ObjectId} productId\n   * @param {String} sizeLabel\n   * @param {Number} qty\n   * @param {mongoose.ClientSession} [session]\n   * @returns {Promise<void>}\n   * @throws {InvalidParamsError}\n   */\n  static async addOrCreateSize(productId, sizeLabel, qty = 0, session = null) {\n    if (!productId) throw new InvalidParamsError(\"productId is required\");\n    const label = this._normalizeLabel(sizeLabel);\n    if (!label) throw new InvalidParamsError(\"sizeLabel is required\");\n    const q = Math.max(0, Math.floor(Number(qty) || 0));\n    const options = { arrayFilters: [{ \"el.label\": label }] };\n    if (session) options.session = session;\n\n    // Try update first; if not matched, push a new size\n    const res = await Product.updateOne(\n      { _id: productId, \"sizes.label\": label },\n      { $set: { \"sizes.$[el].stock\": q } },\n      options\n    );\n\n    if ((res.modifiedCount ?? res.nModified ?? 0) === 0) {\n      await Product.updateOne(\n        { _id: productId },\n        { $push: { sizes: { label, stock: q } } },\n        session ? { session } : {}\n      );\n    }\n  }\n\n  /**\n   * Get stock for a specific size. Returns 0 if product or size not found.\n   * @param {String|ObjectId} productId\n   * @param {String} sizeLabel\n   * @returns {Promise<number>}\n   */\n  static async getStock(productId, sizeLabel) {\n    if (!productId) throw new InvalidParamsError(\"productId is required\");\n    const label = this._normalizeLabel(sizeLabel);\n    if (!label) throw new InvalidParamsError(\"sizeLabel is required\");\n\n    const doc = await Product.findById(productId, { sizes: 1 }).lean();\n    if (!doc || !Array.isArray(doc.sizes)) return 0;\n    const s = doc.sizes.find(x => String(x.label).trim() === label);\n    return s ? Number(s.stock || 0) : 0;\n  }\n\n  /**\n   * Returns total stock across all sizes for the product (integer).\n   * @param {String|ObjectId} productId\n   * @returns {Promise<number>}\n   */\n  static async totalStock(productId) {\n    if (!productId) throw new InvalidParamsError(\"productId is required\");\n    const doc = await Product.findById(productId, { sizes: 1 }).lean();\n    if (!doc || !Array.isArray(doc.sizes)) return 0;\n    return doc.sizes.reduce((sum, s) => sum + Math.max(0, Number(s.stock || 0)), 0);\n  }\n\n  /**\n   * Decrease stock for multiple items inside a session/transaction.\n   * This method expects a mongoose session that has had startTransaction called.\n   * It will throw InsufficientStockError if any individual decrement cannot be applied.\n   *\n   * @param {Array<{productId: string, sizeLabel: string, qty: number}>} items\n   * @param {mongoose.ClientSession} session - required\n   * @returns {Promise<void>}\n   * @throws {InvalidParamsError|InsufficientStockError}\n   */\n  static async decreaseStockForItems(items = [], session) {\n    if (!Array.isArray(items) || items.length === 0) return;\n    if (!session) throw new InvalidParamsError(\"A mongoose session is required for multi-item decrease\");\n\n    // Validate items and normalize labels\n    for (const it of items) {\n      it.sizeLabel = this._normalizeLabel(it.sizeLabel);\n      this._validateParams(it.productId, it.sizeLabel, it.qty);\n    }\n\n    // Attempt each update; on failure fetch available and throw InsufficientStockError\n    for (const it of items) {\n      const updated = await Product.updateOne(\n        {\n          _id: it.productId,\n          \"sizes.label\": it.sizeLabel,\n          \"sizes.stock\": { $gte: it.qty }\n        },\n        { $inc: { \"sizes.$[el].stock\": -it.qty } },\n        { arrayFilters: [{ \"el.label\": it.sizeLabel }], session }\n      );\n\n      const modified = (updated.modifiedCount ?? updated.nModified ?? 0) > 0;\n      if (!modified) {\n        const current = await Product.findOne(\n          { _id: it.productId, \"sizes.label\": it.sizeLabel },\n          { \"sizes.$\": 1 }\n        ).session(session).lean();\n\n        const available = current && current.sizes && current.sizes[0] ? Number(current.sizes[0].stock || 0) : 0;\n        throw new InsufficientStockError(\n          `Insufficient stock for product ${it.productId} size ${it.sizeLabel}. Requested ${it.qty}, available ${available}`\n        );\n      }\n    }\n    // all decrements succeeded (still inside caller's transaction)\n  }\n}\n\n// Export error classes for callers that want to check error types.\nexport { InventoryError, InsufficientStockError, InvalidParamsError };\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 547, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/untitled%20folder/src/services/orderService.js"],"sourcesContent":["// src/services/orderService.js\nimport mongoose from \"mongoose\";\nimport Order from \"models/orderModel.js\";\nimport Product from \"models/productModel.js\";\nimport InventoryService from \"./inventory.js\";\n\n/**\n * @class OrderService\n * @brief Handles order creation and listing; coordinates inventory changes transactionally.\n *\n * createOrder runs inside a mongoose transaction to atomically:\n *  - validate items and snapshot product data\n *  - decrement inventory via InventoryService (which uses the same session)\n *  - create the order document and commit\n *\n * Errors:\n *  - OrderError for general validation\n *  - InsufficientStockError for stock failures (mapped to 409 by the API layer)\n */\n\nclass OrderError extends Error {}\nclass InsufficientStockError extends OrderError {}\n\nexport default class OrderService {\n  /**\n   * Create an order atomically: validates items, decrements stock, and saves order doc.\n   * @param {Object} customer - { name, email, phone, address }\n   * @param {Array<{productId, sizeLabel, qty}>} items\n   * @returns {Promise<Object>} saved Mongoose Order document\n   * @throws {OrderError|InsufficientStockError|Error}\n   */\n  static async createOrder(customer = {}, items = []) {\n    if (!Array.isArray(items) || items.length === 0) {\n      throw new OrderError(\"Order must contain at least one item\");\n    }\n\n    const session = await mongoose.startSession();\n    try {\n      session.startTransaction();\n\n      // 1) Load product docs for all requested items (inside session)\n      const productIds = [...new Set(items.map(i => String(i.productId)))];\n      const products = await Product.find({ _id: { $in: productIds } }).session(session).lean();\n      const productMap = new Map(products.map(p => [String(p._id), p]));\n\n      // 2) Build order items with snapshots and validation\n      const orderItems = [];\n      for (const it of items) {\n        const pid = String(it.productId);\n        const doc = productMap.get(pid);\n        if (!doc) {\n          throw new OrderError(`Product not found: ${pid}`);\n        }\n\n        const qty = Math.max(0, Math.floor(Number(it.qty || 0)));\n        if (qty <= 0) throw new OrderError(`Invalid quantity for product ${pid}`);\n\n        const size = Array.isArray(doc.sizes) ? doc.sizes.find(s => s.label === it.sizeLabel) : null;\n        if (!size) throw new OrderError(`Size '${it.sizeLabel}' not found for product ${pid}`);\n\n        const unitPrice = Number(doc.price || 0);\n        const subtotal = unitPrice * qty;\n\n        orderItems.push({\n          productId: doc._id,\n          name: doc.name,\n          sizeLabel: it.sizeLabel,\n          qty,\n          unitPrice,\n          subtotal\n        });\n      }\n\n      // 3) Attempt multi-item atomic stock decrement using InventoryService (throws on insufficient)\n      const inventoryItems = items.map(i => ({ productId: i.productId, sizeLabel: i.sizeLabel, qty: i.qty }));\n      await InventoryService.decreaseStockForItems(inventoryItems, session);\n\n      // 4) Calculate totals\n      const subtotal = orderItems.reduce((s, it) => s + (it.subtotal || 0), 0);\n      const shipping = 0;\n      const tax = 0;\n      const discount = 0;\n      const total = subtotal + shipping + tax - discount;\n\n      // 5) Create order doc (inside same transaction)\n      const orderDoc = new Order({\n        customer,\n        items: orderItems,\n        subtotal,\n        shipping,\n        tax,\n        discount,\n        total,\n        status: \"created\"\n      });\n\n      const saved = await orderDoc.save({ session });\n\n      await session.commitTransaction();\n      session.endSession();\n\n      return saved;\n    } catch (err) {\n      // abort and map inventory-specific error to domain InsufficientStockError\n      try {\n        await session.abortTransaction();\n      } catch (_) {}\n      session.endSession();\n\n      // InventoryService throws InsufficientStockError (same name) - rethrow as Order-level InsufficientStockError\n      if (err && (err.name === \"InsufficientStockError\" || err instanceof Error && err.constructor?.name === \"InsufficientStockError\")) {\n        throw new InsufficientStockError(err.message);\n      }\n      // propagate other errors\n      throw err;\n    }\n  }\n\n  /**\n   * List orders with optional userId filter and pagination.\n   * @param {Object} opts\n   * @param {String} [opts.userId]\n   * @param {number} [opts.page=1]\n   * @param {number} [opts.limit=20]\n   * @returns {Promise<{items:Object[], total:number, page:number, limit:number}>}\n   */\n  static async listOrders({ userId, page = 1, limit = 20 } = {}) {\n    const filter = {};\n    if (userId) filter.userId = userId;\n    const skip = Math.max(0, (Number(page) - 1) * Number(limit));\n    const items = await Order.find(filter).sort({ createdAt: -1 }).skip(skip).limit(Number(limit)).lean();\n    const total = await Order.countDocuments(filter);\n    return { items, total, page: Number(page), limit: Number(limit) };\n  }\n\n  // TODO: add getById, updateStatus, refund helpers with JSDoc/Doxygen comments when required.\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 697, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/untitled%20folder/src/pages/api/orders/index.js"],"sourcesContent":["// src/pages/api/orders/index.js\nimport dbConnect from \"lib/dbConnect.js\";\nimport OrderService from \"services/orderService.js\";\n\n/**\n * API Handler: /api/orders\n *\n * POST -> create order\n * GET  -> list orders (query: page, limit)\n *\n * Errors:\n *  - 400 for validation\n *  - 409 for insufficient stock\n *  - 500 for server/db errors\n */\nexport default async function handler(req, res) {\n  try {\n    await dbConnect();\n  } catch (err) {\n    console.error(\"DB connect failed:\", err);\n    return res.status(500).json({ error: \"Database connection failed\" });\n  }\n\n  if (req.method === \"POST\") {\n    try {\n      const { customer, items } = req.body;\n\n      if (!Array.isArray(items) || items.length === 0) {\n        return res.status(400).json({ error: \"items array is required\" });\n      }\n      if (!customer || !customer.name) {\n        return res.status(400).json({ error: \"customer.name is required\" });\n      }\n\n      const created = await OrderService.createOrder(customer, items);\n      return res.status(201).json(created);\n    } catch (err) {\n      console.error(\"POST /api/orders error:\", err);\n      if (err.name === \"InsufficientStockError\") {\n        return res.status(409).json({ error: err.message });\n      }\n      if (err.name === \"OrderError\") {\n        return res.status(400).json({ error: err.message });\n      }\n      return res.status(500).json({ error: err.message || \"Failed to create order\" });\n    }\n  }\n\n  if (req.method === \"GET\") {\n    try {\n      const { page = \"1\", limit = \"20\" } = req.query;\n      const result = await OrderService.listOrders({ page: Number(page), limit: Number(limit) });\n      return res.status(200).json(result);\n    } catch (err) {\n      console.error(\"GET /api/orders error:\", err);\n      return res.status(500).json({ error: \"Failed to list orders\" });\n    }\n  }\n\n  res.setHeader(\"Allow\", [\"GET\", \"POST\"]);\n  return res.status(405).end(`Method ${req.method} Not Allowed`);\n}\n"],"names":[],"mappings":"AAAA,gCAAgC;;;;;AAChC;AACA;;;AAae,eAAe,QAAQ,GAAG,EAAE,GAAG;IAC5C,IAAI;QACF,MAAM,IAAA,2HAAS;IACjB,EAAE,OAAO,KAAK;QACZ,QAAQ,KAAK,CAAC,sBAAsB;QACpC,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,OAAO;QAA6B;IACpE;IAEA,IAAI,IAAI,MAAM,KAAK,QAAQ;QACzB,IAAI;YACF,MAAM,EAAE,QAAQ,EAAE,KAAK,EAAE,GAAG,IAAI,IAAI;YAEpC,IAAI,CAAC,MAAM,OAAO,CAAC,UAAU,MAAM,MAAM,KAAK,GAAG;gBAC/C,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;oBAAE,OAAO;gBAA0B;YACjE;YACA,IAAI,CAAC,YAAY,CAAC,SAAS,IAAI,EAAE;gBAC/B,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;oBAAE,OAAO;gBAA4B;YACnE;YAEA,MAAM,UAAU,MAAM,mIAAY,CAAC,WAAW,CAAC,UAAU;YACzD,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;QAC9B,EAAE,OAAO,KAAK;YACZ,QAAQ,KAAK,CAAC,2BAA2B;YACzC,IAAI,IAAI,IAAI,KAAK,0BAA0B;gBACzC,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;oBAAE,OAAO,IAAI,OAAO;gBAAC;YACnD;YACA,IAAI,IAAI,IAAI,KAAK,cAAc;gBAC7B,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;oBAAE,OAAO,IAAI,OAAO;gBAAC;YACnD;YACA,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,OAAO,IAAI,OAAO,IAAI;YAAyB;QAC/E;IACF;IAEA,IAAI,IAAI,MAAM,KAAK,OAAO;QACxB,IAAI;YACF,MAAM,EAAE,OAAO,GAAG,EAAE,QAAQ,IAAI,EAAE,GAAG,IAAI,KAAK;YAC9C,MAAM,SAAS,MAAM,mIAAY,CAAC,UAAU,CAAC;gBAAE,MAAM,OAAO;gBAAO,OAAO,OAAO;YAAO;YACxF,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;QAC9B,EAAE,OAAO,KAAK;YACZ,QAAQ,KAAK,CAAC,0BAA0B;YACxC,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,OAAO;YAAwB;QAC/D;IACF;IAEA,IAAI,SAAS,CAAC,SAAS;QAAC;QAAO;KAAO;IACtC,OAAO,IAAI,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC,OAAO,EAAE,IAAI,MAAM,CAAC,YAAY,CAAC;AAC/D","debugId":null}}]
}