{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 22, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/Project%20OOPS%202/src/lib/dbConnect.js"],"sourcesContent":["// lib/dbConnect.js\nimport mongoose from \"mongoose\";\n\n/**\n * @file dbConnect\n * @brief Reusable MongoDB connection util for Next.js API routes.\n *\n * Throws if MONGO_URI missing. Caches connection in global to avoid multiple\n * connections during hot-reload/development.\n */\n\nconst MONGO_URI = process.env.MONGO_URI;\nif (!MONGO_URI) throw new Error(\"MONGO_URI not set\");\n\nlet cached = global._mongoose || { conn: null, promise: null };\nif (!global._mongoose) global._mongoose = cached;\n\n/**\n * Ensure there is a single mongoose connection used across calls.\n * @returns {Promise<mongoose.Mongoose>}\n */\nexport default async function dbConnect() {\n  if (cached.conn) return cached.conn;\n  if (!cached.promise) {\n    // Use the connection string directly; options are managed by mongoose v8 defaults.\n    cached.promise = mongoose.connect(MONGO_URI).then(m => m);\n  }\n  cached.conn = await cached.promise;\n  return cached.conn;\n}\n"],"names":[],"mappings":"AAAA,mBAAmB;;;;;AACnB;;AAEA;;;;;;CAMC,GAED,MAAM,YAAY,QAAQ,GAAG,CAAC,SAAS;AACvC,IAAI,CAAC,WAAW,MAAM,IAAI,MAAM;AAEhC,IAAI,SAAS,yDAAO,SAAS,IAAI;IAAE,MAAM;IAAM,SAAS;AAAK;AAC7D,IAAI,CAAC,yDAAO,SAAS,EAAE,yDAAO,SAAS,GAAG;AAM3B,eAAe;IAC5B,IAAI,OAAO,IAAI,EAAE,OAAO,OAAO,IAAI;IACnC,IAAI,CAAC,OAAO,OAAO,EAAE;QACnB,mFAAmF;QACnF,OAAO,OAAO,GAAG,oHAAQ,CAAC,OAAO,CAAC,WAAW,IAAI,CAAC,CAAA,IAAK;IACzD;IACA,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;IAClC,OAAO,OAAO,IAAI;AACpB","debugId":null}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/Project%20OOPS%202/src/models/orderModel.js"],"sourcesContent":["// models/orderModel.js\nimport mongoose from \"mongoose\";\n\nconst { Schema } = mongoose;\n\n/**\n * Minimal snapshot item schema used inside Order documents.\n */\nconst orderItemSchema = new Schema({\n  productId: { type: Schema.Types.ObjectId, ref: \"Product\", required: true },\n  name: { type: String, required: true },\n  sizeLabel: { type: String, required: true },\n  qty: { type: Number, required: true, min: 1 },\n  unitPrice: { type: Number, required: true },\n  subtotal: { type: Number, required: true },\n  estimatedDelivery: { type: Date }\n}, { _id: false });\n\n/**\n * Status history entries\n */\nconst statusHistorySchema = new Schema({\n  status: { type: String, required: true },\n  at: { type: Date, default: Date.now },\n  note: { type: String }\n}, { _id: false });\n\nconst orderSchema = new Schema({\n  \n  // --- NEW FIELD ---\n  // Tracks which User (Retailer or Wholesaler) is the seller\n  // responsible for fulfilling this order.\n  sellerId: {\n    type: Schema.Types.ObjectId,\n    ref: 'User',\n    required: true, // Every order must have a seller\n    index: true\n  },\n\n  /* --- Existing Fields --- */\n  customer: {\n    name: { type: String, required: true },\n    email: { type: String },\n    phone: { type: String },\n    address: { type: String },\n    customerLocation: { type: Schema.Types.Mixed }\n  },\n  items: { type: [orderItemSchema], required: true },\n\n  subtotal: { type: Number, required: true },\n  shipping: { type: Number, default: 0 },\n  tax: { type: Number, default: 0 },\n  discount: { type: Number, default: 0 },\n  total: { type: Number, required: true },\n\n  status: {\n    type: String,\n    enum: [\n      \"created\", \"ordered\", \"pending\", \"paid\", \"processing\",\n      \"shipped\", \"out_for_delivery\", \"delivered\", \"cancelled\", \"refunded\"\n    ],\n    default: \"created\"\n  },\n\n  statusHistory: { type: [statusHistorySchema], default: [] },\n  estimatedDelivery: { type: Date },\n  payment: {\n    provider: { type: String },\n    paymentId: { type: String },\n    method: { type: String },\n    paidAt: { type: Date },\n    refundedAt: { type: Date },\n    refundInfo: { type: Schema.Types.Mixed }\n  },\n  fulfillment: {\n    trackingNumber: String,\n    carrier: String,\n    shippedAt: Date,\n    outForDeliveryAt: Date,\n    deliveredAt: Date\n  },\n\n  shippedAt: Date,\n  outForDeliveryAt: Date,\n  deliveredAt: Date,\n\n  userId: { type: Schema.Types.ObjectId, ref: \"User\" }, // This is the Customer's ID\n  meta: { type: Schema.Types.Mixed },\n  archived: { type: Boolean, default: false }\n}, { timestamps: true });\n\n// Useful indexes\norderSchema.index({ userId: 1, createdAt: -1 });\norderSchema.index({ \"customer.email\": 1 });\norderSchema.index({ status: 1, createdAt: -1 });\n\n// --- NEW INDEX ---\n// This will make dashboard queries for orders much faster.\norderSchema.index({ sellerId: 1, status: 1, createdAt: -1 });\n\nexport default mongoose.models.Order || mongoose.model(\"Order\", orderSchema);"],"names":[],"mappings":"AAAA,uBAAuB;;;;;AACvB;;AAEA,MAAM,EAAE,MAAM,EAAE,GAAG,oHAAQ;AAE3B;;CAEC,GACD,MAAM,kBAAkB,IAAI,OAAO;IACjC,WAAW;QAAE,MAAM,OAAO,KAAK,CAAC,QAAQ;QAAE,KAAK;QAAW,UAAU;IAAK;IACzE,MAAM;QAAE,MAAM;QAAQ,UAAU;IAAK;IACrC,WAAW;QAAE,MAAM;QAAQ,UAAU;IAAK;IAC1C,KAAK;QAAE,MAAM;QAAQ,UAAU;QAAM,KAAK;IAAE;IAC5C,WAAW;QAAE,MAAM;QAAQ,UAAU;IAAK;IAC1C,UAAU;QAAE,MAAM;QAAQ,UAAU;IAAK;IACzC,mBAAmB;QAAE,MAAM;IAAK;AAClC,GAAG;IAAE,KAAK;AAAM;AAEhB;;CAEC,GACD,MAAM,sBAAsB,IAAI,OAAO;IACrC,QAAQ;QAAE,MAAM;QAAQ,UAAU;IAAK;IACvC,IAAI;QAAE,MAAM;QAAM,SAAS,KAAK,GAAG;IAAC;IACpC,MAAM;QAAE,MAAM;IAAO;AACvB,GAAG;IAAE,KAAK;AAAM;AAEhB,MAAM,cAAc,IAAI,OAAO;IAE7B,oBAAoB;IACpB,2DAA2D;IAC3D,yCAAyC;IACzC,UAAU;QACR,MAAM,OAAO,KAAK,CAAC,QAAQ;QAC3B,KAAK;QACL,UAAU;QACV,OAAO;IACT;IAEA,2BAA2B,GAC3B,UAAU;QACR,MAAM;YAAE,MAAM;YAAQ,UAAU;QAAK;QACrC,OAAO;YAAE,MAAM;QAAO;QACtB,OAAO;YAAE,MAAM;QAAO;QACtB,SAAS;YAAE,MAAM;QAAO;QACxB,kBAAkB;YAAE,MAAM,OAAO,KAAK,CAAC,KAAK;QAAC;IAC/C;IACA,OAAO;QAAE,MAAM;YAAC;SAAgB;QAAE,UAAU;IAAK;IAEjD,UAAU;QAAE,MAAM;QAAQ,UAAU;IAAK;IACzC,UAAU;QAAE,MAAM;QAAQ,SAAS;IAAE;IACrC,KAAK;QAAE,MAAM;QAAQ,SAAS;IAAE;IAChC,UAAU;QAAE,MAAM;QAAQ,SAAS;IAAE;IACrC,OAAO;QAAE,MAAM;QAAQ,UAAU;IAAK;IAEtC,QAAQ;QACN,MAAM;QACN,MAAM;YACJ;YAAW;YAAW;YAAW;YAAQ;YACzC;YAAW;YAAoB;YAAa;YAAa;SAC1D;QACD,SAAS;IACX;IAEA,eAAe;QAAE,MAAM;YAAC;SAAoB;QAAE,SAAS,EAAE;IAAC;IAC1D,mBAAmB;QAAE,MAAM;IAAK;IAChC,SAAS;QACP,UAAU;YAAE,MAAM;QAAO;QACzB,WAAW;YAAE,MAAM;QAAO;QAC1B,QAAQ;YAAE,MAAM;QAAO;QACvB,QAAQ;YAAE,MAAM;QAAK;QACrB,YAAY;YAAE,MAAM;QAAK;QACzB,YAAY;YAAE,MAAM,OAAO,KAAK,CAAC,KAAK;QAAC;IACzC;IACA,aAAa;QACX,gBAAgB;QAChB,SAAS;QACT,WAAW;QACX,kBAAkB;QAClB,aAAa;IACf;IAEA,WAAW;IACX,kBAAkB;IAClB,aAAa;IAEb,QAAQ;QAAE,MAAM,OAAO,KAAK,CAAC,QAAQ;QAAE,KAAK;IAAO;IACnD,MAAM;QAAE,MAAM,OAAO,KAAK,CAAC,KAAK;IAAC;IACjC,UAAU;QAAE,MAAM;QAAS,SAAS;IAAM;AAC5C,GAAG;IAAE,YAAY;AAAK;AAEtB,iBAAiB;AACjB,YAAY,KAAK,CAAC;IAAE,QAAQ;IAAG,WAAW,CAAC;AAAE;AAC7C,YAAY,KAAK,CAAC;IAAE,kBAAkB;AAAE;AACxC,YAAY,KAAK,CAAC;IAAE,QAAQ;IAAG,WAAW,CAAC;AAAE;AAE7C,oBAAoB;AACpB,2DAA2D;AAC3D,YAAY,KAAK,CAAC;IAAE,UAAU;IAAG,QAAQ;IAAG,WAAW,CAAC;AAAE;uCAE3C,oHAAQ,CAAC,MAAM,CAAC,KAAK,IAAI,oHAAQ,CAAC,KAAK,CAAC,SAAS","debugId":null}},
    {"offset": {"line": 262, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/Project%20OOPS%202/src/models/Product.js"],"sourcesContent":["// src/models/Product.js\nimport mongoose from \"mongoose\";\n\nconst { Schema } = mongoose;\n\n/* --- (all your existing sub-schemas) --- */\nconst ReviewSchema = new Schema({\n  rating: { type: Number, required: true, min: 1, max: 5 },\n  comment: { type: String, default: \"\" },\n  author: { type: String },\n  createdAt: { type: Date, default: Date.now },\n});\n\nconst SizeVariantSchema = new Schema({\n  size: { type: String, required: true },\n  sku: { type: String },\n  stock: { type: Number, default: 0 },\n  price: { type: Number },\n});\n\nconst SizeChartSchema = new Schema({\n  chartName: { type: String },\n  data: { type: Schema.Types.Mixed },\n  image: { type: String }\n}, { _id: false });\n\nconst WarehouseSchema = new Schema({\n  name: { type: String },\n  address: { type: String },\n  city: { type: String },\n  state: { type: String },\n  country: { type: String },\n  pincode: { type: String },\n  leadTimeDays: { type: Number, default: 2 },\n  location: {\n    type: { type: String, enum: ['Point'], default: 'Point' },\n    coordinates: { type: [Number], default: undefined },\n  },\n}, { _id: false });\n\n// --- NEW SCHEMA: ManufacturedAtSchema ---\n// Uses the same structure as a warehouse location, but without leadTimeDays\nconst ManufacturedAtSchema = new Schema({\n  name: { type: String }, \n  address: { type: String },\n  city: { type: String },\n  state: { type: String },\n  country: { type: String },\n  pincode: { type: String },\n  location: {\n    type: { type: String, enum: ['Point'], default: 'Point' },\n    coordinates: { type: [Number], default: undefined },\n  },\n}, { _id: false });\n// ----------------------------------------\n\nconst ProductDetailsSchema = new Schema({\n  materialComposition: { type: String },\n  sleeveType: { type: String },\n  materialType: { type: String },\n  fitType: { type: String },\n  length: { type: String },\n  neckStyle: { type: String },\n  countryOfOrigin: { type: String },\n  extras: { type: Schema.Types.Mixed },\n  \n}, { _id: false });\n\n/* --- Main Product Schema --- */\nconst ProductSchema = new Schema({\n  \n  // --- NEW FIELD ---\n  // Tracks who owns this product document (Retailer or Wholesaler).\n  ownerId: {\n    type: Schema.Types.ObjectId,\n    ref: 'User',\n    required: true,\n    index: true\n  },\n\n  // --- NEW FIELD ---\n  // If this is a Retail Listing (ownerId is a Retailer),\n  // this field links back to the Wholesaler's original \"Base Product\".\n  wholesaleSourceId: {\n    type: Schema.Types.ObjectId,\n    ref: 'Product',\n    default: null,\n    index: true\n  },\n  \n  // --- NEW FIELD: Manufactured At Location ---\n  manufacturedAt: {\n    type: ManufacturedAtSchema, // Embedded document\n    default: null,\n  },\n  // -------------------------------------------\n\n  /* --- Existing Fields --- */\n  name: { type: String, required: true, index: true },\n  slug: { type: String, index: true },\n  description: { type: String },\n  brand: { type: String },\n  retailer: { type: String }, // This field is now technically redundant, but we'll leave it.\n  category: { type: String },\n  price: { type: Number, required: true },\n  images: [{ type: String }],\n  sizes: [SizeVariantSchema],\n  sizeChart: SizeChartSchema,\n  productDetails: ProductDetailsSchema,\n  reviews: [ReviewSchema],\n  warehouses: [WarehouseSchema],\n  totalStock: { type: Number, default: 0 },\n  tags: [String],\n  createdAt: { type: Date, default: Date.now },\n  updatedAt: { type: Date, default: Date.now },\n  isPublished: { type: Boolean, default: false, index: true },\n}, { timestamps: true });\n\n/* --- Existing Methods & Statics --- */\n\n/**\n * helper to recalc totalStock (instance method)\n */\nProductSchema.methods.recalculateStock = function () {\n  const sizeStock = (this.sizes || []).reduce((acc, s) => acc + (s.stock || 0), 0);\n  this.totalStock = sizeStock;\n  return this.totalStock;\n};\n\n/**\n * get best delivery estimate\n */\nProductSchema.methods.estimateDeliveryTo = function (customerLocation = {}) {\n  // ... (existing logic) ...\n  const whs = this.warehouses || [];\n  if (!whs.length) return { estimatedDays: null, reason: \"no warehouses configured\" };\n\n  const byPincode = whs.find(w => w.pincode && customerLocation.pincode && w.pincode === customerLocation.pincode);\n  if (byPincode) {\n    return { estimatedDays: byPincode.leadTimeDays, warehouse: byPincode, method: \"pincode-match\" };\n  }\n  // ... (rest of your logic) ...\n  const byCity = whs.find(w => w.city && customerLocation.city && w.city.toLowerCase() === customerLocation.city.toLowerCase());\n  if (byCity) {\n    return { estimatedDays: byCity.leadTimeDays + 1, warehouse: byCity, method: \"city-match\" };\n  }\n  \n  const byState = whs.find(w => w.state && customerLocation.state && w.state.toLowerCase() === customerLocation.state.toLowerCase());\n  if (byState) {\n    return { estimatedDays: byState.leadTimeDays + 2, warehouse: byState, method: \"state-match\" };\n  }\n\n  const minWh = whs.reduce((min, w) => (!min || (w.leadTimeDays < min.leadTimeDays) ? w : min), null);\n  return { estimatedDays: (minWh ? minWh.leadTimeDays + 4 : null), warehouse: minWh, method: \"fallback\" };\n};\n\n/**\n * STATIC HELPER: computeTotalStockForPlainObject\n */\nProductSchema.statics.computeTotalStockForPlainObject = function (productPlain = {}) {\n  // ... (existing logic) ...\n  if (!productPlain) return 0;\n  if (typeof productPlain.totalStock === \"number\" && Array.isArray(productPlain.sizes) === false) {\n    return productPlain.totalStock;\n  }\n  if (Array.isArray(productPlain.sizes)) {\n    return productPlain.sizes.reduce((acc, s) => {\n      const n = s && (typeof s.stock === \"number\" ? s.stock : Number(s?.qty ?? 0));\n      return acc + (Number.isFinite(n) ? n : 0);\n    }, 0);\n  }\n  if (typeof productPlain.stock === \"number\") return productPlain.stock;\n  return 0;\n};\n\n/**\n * OPTIONAL STATIC HELPER: recalculateAndPersist\n */\nProductSchema.statics.recalculateAndPersist = async function (productId) {\n  // ... (existing logic) ...\n  if (!productId) throw new Error(\"productId required\");\n  const Product = this;\n  const doc = await Product.findById(productId);\n  if (!doc) throw new Error(\"product not found\");\n  doc.recalculateStock();\n  await doc.save();\n  return doc.totalStock;\n};\n\nexport default mongoose.models.Product || mongoose.model(\"Product\", ProductSchema);"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 597, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/Project%20OOPS%202/src/models/User.js"],"sourcesContent":["// src/models/User.js\nimport mongoose from \"mongoose\";\n\nconst { Schema } = mongoose; // Destructure Schema for use in sub-schema\n\n// --- UPDATED SUB-SCHEMA: Address (Updated for Geo-location and full name) ---\nconst addressSchema = new Schema({\n  label: { type: String, default: \"Home\" }, \n  firstName: { type: String }, // NEW\n  lastName: { type: String }, // NEW\n  addressLine1: { type: String, required: true }, // Main street address from Google\n  addressLine2: { type: String }, // NEW: For apartment, suite, etc.\n  city: { type: String, required: true },\n  state: { type: String },\n  pincode: { type: String }, \n  country: { type: String, required: true }, // NEW\n  phone: { type: String }, \n  countryCode: { type: String, default: \"+91\" }, // NEW\n  // NEW: GeoJSON structure for map display and future distance queries\n  location: {\n    type: { type: String, enum: ['Point'], default: 'Point' },\n    coordinates: { type: [Number], default: undefined }, // [longitude, latitude]\n  },\n}, { _id: true });\n// --- END UPDATED SUB-SCHEMA ---\n\nconst userSchema = new mongoose.Schema({\n  name: { type: String },\n  email: { type: String, index: true, sparse: true, unique: true },\n  password: { type: String, select: false },\n  oauthProvider: String,\n  oauthId: String,\n  phone: { type: String },\n  role: { type: String, enum: [\"CUSTOMER\",\"RETAILER\",\"WHOLESALER\"], default: \"CUSTOMER\" },\n  verified: { type: Boolean, default: false },\n  otp: {\n    code: String,\n    expiresAt: Date\n  },\n  resetOtp: { type: String },\n  resetOtpExpiry: { type: Number },\n  resetAttempts: { type: Number },\n  addresses: [addressSchema]\n}, { timestamps: true });\n\nexport default mongoose.models.User || mongoose.model(\"User\", userSchema);"],"names":[],"mappings":"AAAA,qBAAqB;;;;;AACrB;;AAEA,MAAM,EAAE,MAAM,EAAE,GAAG,oHAAQ,EAAE,2CAA2C;AAExE,+EAA+E;AAC/E,MAAM,gBAAgB,IAAI,OAAO;IAC/B,OAAO;QAAE,MAAM;QAAQ,SAAS;IAAO;IACvC,WAAW;QAAE,MAAM;IAAO;IAC1B,UAAU;QAAE,MAAM;IAAO;IACzB,cAAc;QAAE,MAAM;QAAQ,UAAU;IAAK;IAC7C,cAAc;QAAE,MAAM;IAAO;IAC7B,MAAM;QAAE,MAAM;QAAQ,UAAU;IAAK;IACrC,OAAO;QAAE,MAAM;IAAO;IACtB,SAAS;QAAE,MAAM;IAAO;IACxB,SAAS;QAAE,MAAM;QAAQ,UAAU;IAAK;IACxC,OAAO;QAAE,MAAM;IAAO;IACtB,aAAa;QAAE,MAAM;QAAQ,SAAS;IAAM;IAC5C,qEAAqE;IACrE,UAAU;QACR,MAAM;YAAE,MAAM;YAAQ,MAAM;gBAAC;aAAQ;YAAE,SAAS;QAAQ;QACxD,aAAa;YAAE,MAAM;gBAAC;aAAO;YAAE,SAAS;QAAU;IACpD;AACF,GAAG;IAAE,KAAK;AAAK;AACf,iCAAiC;AAEjC,MAAM,aAAa,IAAI,oHAAQ,CAAC,MAAM,CAAC;IACrC,MAAM;QAAE,MAAM;IAAO;IACrB,OAAO;QAAE,MAAM;QAAQ,OAAO;QAAM,QAAQ;QAAM,QAAQ;IAAK;IAC/D,UAAU;QAAE,MAAM;QAAQ,QAAQ;IAAM;IACxC,eAAe;IACf,SAAS;IACT,OAAO;QAAE,MAAM;IAAO;IACtB,MAAM;QAAE,MAAM;QAAQ,MAAM;YAAC;YAAW;YAAW;SAAa;QAAE,SAAS;IAAW;IACtF,UAAU;QAAE,MAAM;QAAS,SAAS;IAAM;IAC1C,KAAK;QACH,MAAM;QACN,WAAW;IACb;IACA,UAAU;QAAE,MAAM;IAAO;IACzB,gBAAgB;QAAE,MAAM;IAAO;IAC/B,eAAe;QAAE,MAAM;IAAO;IAC9B,WAAW;QAAC;KAAc;AAC5B,GAAG;IAAE,YAAY;AAAK;uCAEP,oHAAQ,CAAC,MAAM,CAAC,IAAI,IAAI,oHAAQ,CAAC,KAAK,CAAC,QAAQ","debugId":null}},
    {"offset": {"line": 721, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/Project%20OOPS%202/src/services/inventory.js"],"sourcesContent":["// src/services/inventory.js\nimport mongoose from \"mongoose\";\nimport Product from \"models/Product.js\";\n\n/**\n * InventoryService\n *\n * - All operations accept an optional mongoose session for transactional safety.\n * - decreaseStockForItems attempts to decrement each product-size atomically and\n *   throws InsufficientStockError if any item cannot be satisfied.\n *\n * Note: callers (OrderService.createOrder, refund flows) should start a session\n * and transaction when they want the whole operation to be atomic.\n */\n\n/** Base error for inventory operations */\nclass InventoryError extends Error {}\n/** Thrown when requested qty cannot be satisfied */\nclass InsufficientStockError extends InventoryError {}\n/** Thrown when input params are invalid */\nclass InvalidParamsError extends InventoryError {}\n\nexport default class InventoryService {\n  /**\n   * Normalize size label defensively.\n   * @private\n   * @param {any} sizeLabel\n   * @returns {string}\n   */\n  static _normalizeLabel(sizeLabel) {\n    return sizeLabel === undefined || sizeLabel === null ? \"\" : String(sizeLabel).trim();\n  }\n\n  /**\n   * Validate and normalize params for single-item operations.\n   * Throws InvalidParamsError on invalid input.\n   * @private\n   * @param {String|ObjectId} productId\n   * @param {String} sizeLabel\n   * @param {Number} qty\n   * @returns {{productId:*, sizeLabel:string, qty:number}}\n   */\n  static _validateParams(productId, sizeLabel, qty) {\n    if (!productId) throw new InvalidParamsError(\"productId is required\");\n    const label = this._normalizeLabel(sizeLabel);\n    if (!label) throw new InvalidParamsError(\"sizeLabel is required\");\n    const q = Number(qty);\n    if (!Number.isFinite(q) || q <= 0) throw new InvalidParamsError(\"qty must be a positive number\");\n    return { productId, sizeLabel: label, qty: Math.floor(q) };\n  }\n\n  /**\n   * Decrease stock for a specific product size by qty.\n   * If a mongoose session is provided, the update participates in the transaction.\n   * Uses positional $ operator to decrement correct array element.\n   * @param {String|ObjectId} productId\n   * @param {String} sizeLabel\n   * @param {Number} qty\n   * @param {mongoose.ClientSession} [session]\n   * @returns {Promise<boolean>} true if modified, throws InsufficientStockError otherwise\n   * @throws {InvalidParamsError|InsufficientStockError}\n   */\n  static async decreaseStock(productId, sizeLabel, qty, session = null) {\n    const params = this._validateParams(productId, sizeLabel, qty);\n\n    // Filter ensures size exists and has enough stock\n    const filter = {\n      _id: params.productId,\n      \"sizes.size\": params.sizeLabel,\n      \"sizes.stock\": { $gte: params.qty }\n    };\n\n    const update = { $inc: { \"sizes.$.stock\": -params.qty } };\n    const options = {};\n    if (session) options.session = session;\n\n    const res = await Product.updateOne(filter, update, options);\n    const modified = (res.modifiedCount ?? res.nModified ?? 0) > 0;\n\n    if (!modified) {\n      // fetch current available stock for better error message\n      const current = await Product.findOne(\n        { _id: params.productId, \"sizes.size\": params.sizeLabel },\n        { \"sizes.$\": 1 }\n      ).session(session).lean();\n\n      const available = current && current.sizes && current.sizes[0] ? Number(current.sizes[0].stock || 0) : 0;\n      throw new InsufficientStockError(`Insufficient stock for product ${params.productId} size ${params.sizeLabel}. Requested ${params.qty}, available ${available}`);\n    }\n\n    // defensive post-check: ensure new stock is not negative\n    const post = await Product.findOne(\n      { _id: params.productId, \"sizes.size\": params.sizeLabel },\n      { \"sizes.$\": 1 }\n    ).session(session).lean();\n\n    const newStock = post && post.sizes && post.sizes[0] ? Number(post.sizes[0].stock || 0) : 0;\n    if (newStock < 0) {\n      throw new InsufficientStockError(`Post-update stock negative (${newStock}) for product ${params.productId} size ${params.sizeLabel}`);\n    }\n\n    return true;\n  }\n\n  /**\n   * Increase stock for a specific product size by qty (restock/cancel).\n   * Returns true if an existing size was updated, false if not found (size missing).\n   * Use addOrCreateSize to add a missing size.\n   * @param {String|ObjectId} productId\n   * @param {String} sizeLabel\n   * @param {Number} qty\n   * @param {mongoose.ClientSession} [session]\n   * @returns {Promise<boolean>}\n   */\n  static async increaseStock(productId, sizeLabel, qty, session = null) {\n    const params = this._validateParams(productId, sizeLabel, qty);\n\n    const filter = { _id: params.productId, \"sizes.size\": params.sizeLabel };\n    const update = { $inc: { \"sizes.$.stock\": params.qty } };\n    const options = {};\n    if (session) options.session = session;\n\n    const res = await Product.updateOne(filter, update, options);\n    const modified = (res.modifiedCount ?? res.nModified ?? 0) > 0;\n\n    if (modified) {\n      // post-check to ensure validators didn't allow a bad state\n      const post = await Product.findOne(\n        { _id: params.productId, \"sizes.size\": params.sizeLabel },\n        { \"sizes.$\": 1 }\n      ).session(session).lean();\n      const newStock = post && post.sizes && post.sizes[0] ? Number(post.sizes[0].stock || 0) : 0;\n      if (newStock < 0) {\n        throw new InventoryError(`Post-increase stock negative (${newStock}) for product ${params.productId} size ${params.sizeLabel}`);\n      }\n      return true;\n    }\n\n    // size missing -> return false to let callers add/create\n    return false;\n  }\n\n  /**\n   * Add a new size entry if it doesn't exist, or set the stock if it does.\n   * @param {String|ObjectId} productId\n   * @param {String} sizeLabel\n   * @param {Number} qty\n   * @param {mongoose.ClientSession} [session]\n   * @returns {Promise<void>}\n   * @throws {InvalidParamsError}\n   */\n  static async addOrCreateSize(productId, sizeLabel, qty = 0, session = null) {\n    if (!productId) throw new InvalidParamsError(\"productId is required\");\n    const label = this._normalizeLabel(sizeLabel);\n    if (!label) throw new InvalidParamsError(\"sizeLabel is required\");\n    const q = Math.max(0, Math.floor(Number(qty) || 0));\n\n    // Try to update existing size's stock (set to q)\n    const setRes = await Product.updateOne(\n      { _id: productId, \"sizes.size\": label },\n      { $set: { \"sizes.$.stock\": q } },\n      session ? { session } : {}\n    );\n\n    const modified = (setRes.modifiedCount ?? setRes.nModified ?? 0) > 0;\n    if (modified) return;\n\n    // If not modified, push a new size\n    await Product.updateOne(\n      { _id: productId },\n      { $push: { sizes: { size: label, stock: q } } },\n      session ? { session } : {}\n    );\n  }\n\n  /**\n   * Get stock for a specific size. Returns 0 if product or size not found.\n   * @param {String|ObjectId} productId\n   * @param {String} sizeLabel\n   * @returns {Promise<number>}\n   */\n  static async getStock(productId, sizeLabel) {\n    if (!productId) throw new InvalidParamsError(\"productId is required\");\n    const label = this._normalizeLabel(sizeLabel);\n    if (!label) throw new InvalidParamsError(\"sizeLabel is required\");\n\n    const doc = await Product.findById(productId, { sizes: 1 }).lean();\n    if (!doc || !Array.isArray(doc.sizes)) return 0;\n    const s = doc.sizes.find(x => String(x.size).trim() === label);\n    return s ? Number(s.stock || 0) : 0;\n  }\n\n  /**\n   * Returns total stock across all sizes for the product (integer).\n   * @param {String|ObjectId} productId\n   * @returns {Promise<number>}\n   */\n  static async totalStock(productId) {\n    if (!productId) throw new InvalidParamsError(\"productId is required\");\n    const doc = await Product.findById(productId, { sizes: 1 }).lean();\n    if (!doc || !Array.isArray(doc.sizes)) return 0;\n    return doc.sizes.reduce((sum, s) => sum + Math.max(0, Number(s.stock || 0)), 0);\n  }\n\n  /**\n   * Decrease stock for multiple items inside a session/transaction.\n   * This method expects a mongoose session that has had startTransaction called.\n   * It will throw InsufficientStockError if any individual decrement cannot be applied.\n   *\n   * @param {Array<{productId: string, sizeLabel: string, qty: number}>} items\n   * @param {mongoose.ClientSession} session - required\n   * @returns {Promise<void>}\n   * @throws {InvalidParamsError|InsufficientStockError}\n   */\n  static async decreaseStockForItems(items = [], session) {\n    if (!Array.isArray(items) || items.length === 0) return;\n    if (!session) throw new InvalidParamsError(\"A mongoose session is required for multi-item decrease\");\n\n    // Validate items and normalize labels\n    for (const it of items) {\n      it.sizeLabel = this._normalizeLabel(it.sizeLabel);\n      this._validateParams(it.productId, it.sizeLabel, it.qty);\n    }\n\n    // Attempt each update; on failure fetch available and throw InsufficientStockError\n    for (const it of items) {\n      const updated = await Product.updateOne(\n        {\n          _id: it.productId,\n          \"sizes.size\": it.sizeLabel,\n          \"sizes.stock\": { $gte: it.qty }\n        },\n        { $inc: { \"sizes.$.stock\": -it.qty } },\n        { session, runValidators: true }\n      );\n\n      const modified = (updated.modifiedCount ?? updated.nModified ?? 0) > 0;\n      if (!modified) {\n        const current = await Product.findOne(\n          { _id: it.productId, \"sizes.size\": it.sizeLabel },\n          { \"sizes.$\": 1 }\n        ).session(session).lean();\n\n        const available = current && current.sizes && current.sizes[0] ? Number(current.sizes[0].stock || 0) : 0;\n        throw new InsufficientStockError(\n          `Insufficient stock for product ${it.productId} size ${it.sizeLabel}. Requested ${it.qty}, available ${available}`\n        );\n      }\n\n      // post-check\n      const post = await Product.findOne(\n        { _id: it.productId, \"sizes.size\": it.sizeLabel },\n        { \"sizes.$\": 1 }\n      ).session(session).lean();\n\n      const newStock = post && post.sizes && post.sizes[0] ? Number(post.sizes[0].stock || 0) : 0;\n      if (newStock < 0) {\n        throw new InsufficientStockError(\n          `Post-update stock negative (${newStock}) for product ${it.productId} size ${it.sizeLabel}`\n        );\n      }\n    }\n    // all decrements succeeded (still inside caller's transaction)\n  }\n}\n\n// Export error classes for callers that want to check error types.\nexport { InventoryError, InsufficientStockError, InvalidParamsError };\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1006, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/Project%20OOPS%202/src/services/orderService.js"],"sourcesContent":["// src/services/orderService.js\nimport mongoose from \"mongoose\";\nimport Order from \"models/orderModel.js\";\nimport Product from \"models/Product.js\";\nimport User from \"models/User.js\"; // Required to check buyer role\nimport InventoryService, { InsufficientStockError as InvInsufficientStockError } from \"./inventory.js\";\n\n/**\n * @file OrderService\n * @brief Order creation and lifecycle helpers (get, list, status updates, refunds).\n *\n * This service coordinates with InventoryService for stock changes and uses\n * mongoose transactions to ensure atomic operations when modifying inventory\n * and orders together.\n */\n\n/** Base order error */\nclass OrderError extends Error {}\n/** Thrown when stock cannot be satisfied during create/update */\nclass InsufficientStockError extends OrderError {}\n/** Thrown when invalid input supplied */\nclass InvalidOrderParamsError extends OrderError {}\n\nexport default class OrderService {\n  /**\n   * Create an order atomically: validates items, decrements stock, and saves order doc.\n   *\n   * On success the saved Mongoose Order document is returned.\n   *\n   * @param {Object} customer - { name, email, phone, address, customerLocation? }\n   * @param {Array<{productId, sizeLabel, qty}>} items\n   * @param {String} sellerId - The ID of the seller (Retailer or Wholesaler)\n   * @param {String} userId - The ID of the buyer (if they are a registered Retailer)\n   * @returns {Promise<Object>} saved Mongoose Order document\n   * @throws {OrderError|InsufficientStockError|Error}\n   */\n  static async createOrder(customer = {}, items = [], sellerId = null, userId = null)  {\n    if (!Array.isArray(items) || items.length === 0) {\n      throw new OrderError(\"Order must contain at least one item\");\n    }\n\n    const session = await mongoose.startSession();\n    try {\n      session.startTransaction();\n\n      // 1) Load product docs for all requested items (inside session) as model instances (no .lean())\n      const productIds = [...new Set(items.map(i => String(i.productId)))];\n      const products = await Product.find({ _id: { $in: productIds } }).session(session);\n      const productMap = new Map(products.map(p => [String(p._id), p]));\n\n      // 2) Build order items with snapshots and validation\n      const orderItems = [];\n      for (const it of items) {\n        const pid = String(it.productId);\n        const doc = productMap.get(pid);\n        if (!doc) {\n          throw new OrderError(`Product not found: ${pid}`);\n        }\n\n        const qty = Math.max(0, Math.floor(Number(it.qty || 0)));\n        if (qty <= 0) throw new OrderError(`Invalid quantity for product ${pid}`);\n\n        // For B2B (Retailer buying from Wholesaler), we might skip size checks if the wholesaler just sells \"boxes\"\n        // But for now, let's assume strict sizing.\n        const size = Array.isArray(doc.sizes) ? doc.sizes.find(s => s.size === it.sizeLabel || s.size === it.size) : null;\n        if (!size) throw new OrderError(`Size '${it.sizeLabel}' not found for product ${pid}`);\n\n        const unitPrice = Number(size?.price ?? doc.price ?? 0);\n        const subtotal = unitPrice * qty;\n\n        orderItems.push({\n          productId: doc._id,\n          name: doc.name,\n          sizeLabel: it.sizeLabel,\n          qty,\n          unitPrice,\n          subtotal\n          // per-item estimatedDelivery will be added later if available\n        });\n      }\n\n      // 3) Attempt multi-item atomic stock decrement using InventoryService (throws on insufficient)\n      const inventoryItems = items.map(i => ({ productId: i.productId, sizeLabel: i.sizeLabel, qty: i.qty }));\n      await InventoryService.decreaseStockForItems(inventoryItems, session);\n\n      // 4) Calculate totals\n      const subtotal = orderItems.reduce((s, it) => s + (it.subtotal || 0), 0);\n      const shipping = 0;\n      const tax = 0;\n      const discount = 0;\n      const total = subtotal + shipping + tax - discount;\n\n      // ----------------------------\n      // Compute estimated delivery\n      // ----------------------------\n      // Use the Product instance method estimateDeliveryTo(customerLocation) if available.\n      const customerLocation = (customer && (customer.customerLocation || customer.location)) || {};\n      const perItemEstimates = [];\n\n      for (let idx = 0; idx < orderItems.length; idx++) {\n        const it = orderItems[idx];\n        const prod = productMap.get(String(it.productId));\n        if (!prod) continue;\n\n        try {\n          // product.estimateDeliveryTo may be sync or async; await works for either\n          const raw = await prod.estimateDeliveryTo(customerLocation || {});\n          if (raw) {\n            const date = raw instanceof Date ? raw : new Date(raw);\n            if (!isNaN(date.getTime())) {\n              perItemEstimates.push(date);\n              // store per-item ETA on the snapshot (optional but useful)\n              it.estimatedDelivery = date;\n            }\n          }\n        } catch (e) {\n          // ignore individual product estimator errors â€” preserve order creation\n          console.warn(`estimateDeliveryTo failed for product ${prod._id}:`, e && e.message);\n        }\n      }\n\n      // Aggregate: choose latest date so order ETA covers all items.\n      let estimatedDelivery = null;\n      if (perItemEstimates.length > 0) {\n        estimatedDelivery = new Date(Math.max(...perItemEstimates.map(d => d.getTime())));\n      } else {\n        // fallback default (5 days)\n        estimatedDelivery = new Date(Date.now() + 5 * 24 * 60 * 60 * 1000);\n      }\n\n      // 5) Create order doc (inside same transaction) with statusHistory and ETA\n      const now = new Date();\n      const initialStatus = \"ordered\"; // set to 'ordered' to reflect placed order\n      const orderDoc = new Order({\n        sellerId: sellerId,\n        userId: userId, // IMPORTANT: Link the order to the Retailer (buyer)\n        customer,\n        items: orderItems,\n        subtotal,\n        shipping,\n        tax,\n        discount,\n        total,\n        status: initialStatus,\n        statusHistory: [{ status: initialStatus, at: now, note: \"Order placed\" }],\n        estimatedDelivery\n      });\n\n      const saved = await orderDoc.save({ session });\n\n      await session.commitTransaction();\n      session.endSession();\n\n      return saved;\n    } catch (err) {\n      try {\n        await session.abortTransaction();\n      } catch (_) {}\n      session.endSession();\n\n      // Map inventory error to domain-level InsufficientStockError\n      if (err && (err.name === \"InsufficientStockError\" || err instanceof InvInsufficientStockError)) {\n        throw new InsufficientStockError(err.message);\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Internal helper: Transfers stock to the Retailer's inventory when their B2B order is delivered.\n   * * @private\n   * @param {Object} order - The order document\n   * @param {mongoose.ClientSession} session\n   */\n  static async _transferStockToRetailer(order, session) {\n    // 1. Check if the buyer (userId) is actually a Retailer\n    if (!order.userId) return; // Normal customer order, no stock transfer needed\n    const buyer = await User.findById(order.userId).session(session);\n    if (!buyer || buyer.role !== \"RETAILER\") return; // Only transfer stock for Retailers\n\n    // 2. For each item in the order, add it to the Retailer's inventory\n    for (const item of order.items) {\n      // Check if Retailer already has a listing for this wholesale product\n      let retailerProduct = await Product.findOne({\n        ownerId: buyer._id,\n        wholesaleSourceId: item.productId\n      }).session(session);\n\n      if (retailerProduct) {\n        // A. Product exists -> Increase stock for that size\n        const sizeIndex = retailerProduct.sizes.findIndex(s => s.size === item.sizeLabel);\n        \n        if (sizeIndex > -1) {\n          // Size exists, increment stock\n          await Product.updateOne(\n            { _id: retailerProduct._id, \"sizes.size\": item.sizeLabel },\n            { $inc: { \"sizes.$.stock\": item.qty } },\n            { session }\n          );\n        } else {\n          // Size doesn't exist, push new size to array\n          await Product.updateOne(\n            { _id: retailerProduct._id },\n            { $push: { sizes: { size: item.sizeLabel, stock: item.qty, sku: `${retailerProduct.slug}-${item.sizeLabel}` } } },\n            { session }\n          );\n        }\n      } else {\n        // B. Product doesn't exist -> Create it (Copy from Wholesaler)\n        const wholesaleProduct = await Product.findById(item.productId).session(session);\n        if (!wholesaleProduct) continue; \n\n        const newProductData = {\n          ...wholesaleProduct.toObject(),\n          _id: new mongoose.Types.ObjectId(), // New ID\n          ownerId: buyer._id,\n          wholesaleSourceId: wholesaleProduct._id,\n          isPublished: false,\n          // Set initial stock only for the ordered size\n          sizes: [{ \n            size: item.sizeLabel, \n            stock: item.qty, \n            sku: `${wholesaleProduct.slug}-${item.sizeLabel}` \n          }],\n          totalStock: item.qty,\n          price: wholesaleProduct.price * 1.2, // Default markup 20% (Retailer can change later)\n          createdAt: new Date(),\n          updatedAt: new Date(),\n          __v: 0\n        };\n        \n        // Create the product inside the session\n        await Product.create([newProductData], { session });\n      }\n    }\n  }\n\n  /**\n   * List orders with optional userId filter and pagination.\n   * @param {Object} opts\n   * @param {String} [opts.userId]\n   * @param {number} [opts.page=1]\n   * @param {number} [opts.limit=20]\n   * @returns {Promise<{items:Object[], total:number, page:number, limit:number}>}\n   */\n  static async listOrders({ userId, page = 1, limit = 20 } = {}) {\n    const filter = {};\n    if (userId) filter.userId = userId;\n    const skip = Math.max(0, (Number(page) - 1) * Number(limit));\n    const items = await Order.find(filter).sort({ createdAt: -1 }).skip(skip).limit(Number(limit)).lean();\n    const total = await Order.countDocuments(filter);\n    return { items, total, page: Number(page), limit: Number(limit) };\n  }\n\n  /**\n   * Get a single order by id.\n   * @param {String} id - Order ObjectId/string\n   * @returns {Promise<Object|null>}\n   */\n  static async getById(id) {\n    if (!id) throw new InvalidOrderParamsError(\"Order id is required\");\n    const doc = await Order.findById(id).lean();\n    return doc || null;\n  }\n\n  /**\n   * Internal helper: restore stock for an order's items inside a session.\n   * If a product size doesn't exist, it will be created with the restored qty.\n   *\n   * @private\n   * @param {Object[]} items - order items array (having productId, sizeLabel, qty)\n   * @param {mongoose.ClientSession} session\n   */\n  static async _restoreStockForItems(items = [], session) {\n    if (!Array.isArray(items) || items.length === 0) return;\n    if (!session) throw new InvalidOrderParamsError(\"A mongoose session is required for restore\");\n\n    // For each item: attempt increaseStock; if increaseStock returns false (size missing) use addOrCreateSize then increaseStock\n    for (const it of items) {\n      const productId = it.productId;\n      const sizeLabel = it.sizeLabel;\n      const qty = it.qty;\n\n      // attempt to increase (if size exists)\n      const increased = await InventoryService.increaseStock(productId, sizeLabel, qty, session);\n      if (!increased) {\n        // ensure size exists and set stock (preserve existing behavior)\n        await InventoryService.addOrCreateSize(productId, sizeLabel, qty, session);\n      }\n    }\n  }\n\n  /**\n   * Update the status of an order. Optionally restore stock when transitioning to cancelled/refunded.\n   *\n   * This method now appends a statusHistory entry automatically for every transition.\n   *\n   * @param {String} id - order id\n   * @param {String} newStatus - one of orderSchema enum statuses\n   * @param {Object} [opts]\n   * @param {Boolean} [opts.restoreStock=false] - when true and transitioning to cancelled/refunded, restores stock\n   * @returns {Promise<Object>} updated order document\n   * @throws {OrderError|InsufficientStockError|Error}\n   */\n  static async updateStatus(id, newStatus, { restoreStock = false } = {}) {\n    if (!id) throw new InvalidOrderParamsError(\"Order id is required\");\n    if (!newStatus || typeof newStatus !== \"string\") throw new InvalidOrderParamsError(\"newStatus is required\");\n\n    const VALID_STATUSES = [\"created\",\"ordered\",\"pending\",\"paid\",\"processing\",\"shipped\",\"out_for_delivery\",\"delivered\",\"cancelled\",\"refunded\"];\n    if (!VALID_STATUSES.includes(newStatus)) {\n      throw new InvalidOrderParamsError(`Invalid status: ${newStatus}`);\n    }\n\n    const session = await mongoose.startSession();\n    try {\n      session.startTransaction();\n\n      const order = await Order.findById(id).session(session);\n      if (!order) throw new OrderError(\"Order not found\");\n\n      const prevStatus = order.status;\n\n      // restore stock if requested and moving to cancelled/refunded\n      const shouldRestore = restoreStock && (newStatus === \"cancelled\" || newStatus === \"refunded\");\n      if (shouldRestore) {\n        await OrderService._restoreStockForItems(order.items, session);\n      }\n\n      // --- NEW: Trigger Stock Transfer on Delivery (for B2B) ---\n      if (newStatus === \"delivered\" && prevStatus !== \"delivered\") {\n         await OrderService._transferStockToRetailer(order, session);\n      }\n\n      // set status and append to statusHistory\n      const now = new Date();\n      order.status = newStatus;\n      order.statusHistory = order.statusHistory || [];\n      order.statusHistory.push({\n        status: newStatus,\n        at: now,\n        note: `Status changed from ${prevStatus} to ${newStatus}`\n      });\n\n      // Set fulfillment/top-level timestamps where relevant\n      if (newStatus === \"shipped\") {\n        order.fulfillment = order.fulfillment || {};\n        order.fulfillment.shippedAt = order.fulfillment.shippedAt || now;\n        order.shippedAt = order.shippedAt || now;\n      } else if (newStatus === \"out_for_delivery\") {\n        order.fulfillment = order.fulfillment || {};\n        order.fulfillment.outForDeliveryAt = order.fulfillment.outForDeliveryAt || now;\n        order.outForDeliveryAt = order.outForDeliveryAt || now;\n      } else if (newStatus === \"delivered\") {\n        order.fulfillment = order.fulfillment || {};\n        order.fulfillment.deliveredAt = order.fulfillment.deliveredAt || now;\n        order.deliveredAt = order.deliveredAt || now;\n      } else if (newStatus === \"refunded\") {\n        order.payment = order.payment || {};\n        order.payment.refundedAt = order.payment.refundedAt || now;\n        order.payment.refundInfo = order.payment.refundInfo || {};\n        // keep meta/refund trace as well\n        order.meta = order.meta || {};\n        order.meta.refund = Object.assign({}, order.meta.refund || {}, { at: now });\n      }\n\n      const saved = await order.save({ session });\n\n      await session.commitTransaction();\n      session.endSession();\n\n      return saved;\n    } catch (err) {\n      try {\n        await session.abortTransaction();\n      } catch (_) {}\n      session.endSession();\n\n      if (err && (err.name === \"InsufficientStockError\" || err instanceof InvInsufficientStockError)) {\n        throw new InsufficientStockError(err.message);\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Process a refund for an order id.\n   *\n   * Behavior:\n   * - marks order.status = 'refunded'\n   * - optionally restores stock (default true)\n   * - records refund metadata in payment.refundInfo and meta.refund\n   *\n   * NOTE: actual payment-provider refund must be orchestrated outside or before calling this,\n   * this method only reflects refund in DB and inventory.\n   *\n   * @param {String} id - order id\n   * @param {Object} [opts]\n   * @param {Boolean} [opts.restoreStock=true]\n   * @param {Object} [opts.refundInfo] - arbitrary refund metadata (provider, refundId, amount, note)\n   * @returns {Promise<Object>} updated order document\n   * @throws {OrderError|InsufficientStockError|Error}\n   */\n  static async refundOrder(id, { restoreStock = true, refundInfo = {} } = {}) {\n    if (!id) throw new InvalidOrderParamsError(\"Order id is required\");\n\n    const session = await mongoose.startSession();\n    try {\n      session.startTransaction();\n\n      const order = await Order.findById(id).session(session);\n      if (!order) throw new OrderError(\"Order not found\");\n\n      if (order.status === \"refunded\") {\n        // already refunded; nothing to do\n        await session.commitTransaction();\n        session.endSession();\n        return order;\n      }\n\n      // Restore stock before marking refunded\n      if (restoreStock) {\n        await OrderService._restoreStockForItems(order.items, session);\n      }\n\n      // Mark payment/refund metadata and status\n      const now = new Date();\n      order.status = \"refunded\";\n      order.statusHistory = order.statusHistory || [];\n      order.statusHistory.push({\n        status: \"refunded\",\n        at: now,\n        note: \"Order refunded\"\n      });\n\n      order.payment = order.payment || {};\n      order.payment.refundInfo = Object.assign({}, order.payment.refundInfo || {}, refundInfo);\n      order.payment.refundedAt = order.payment.refundedAt || now;\n\n      // also keep refund trace in meta\n      order.meta = order.meta || {};\n      order.meta.refund = Object.assign({}, order.meta.refund || {}, { at: now, info: refundInfo });\n\n      const saved = await order.save({ session });\n\n      await session.commitTransaction();\n      session.endSession();\n\n      return saved;\n    } catch (err) {\n      try {\n        await session.abortTransaction();\n      } catch (_) {}\n      session.endSession();\n\n      if (err && (err.name === \"InsufficientStockError\" || err instanceof InvInsufficientStockError)) {\n        throw new InsufficientStockError(err.message);\n      }\n      throw err;\n    }\n  }\n}\n\nexport { OrderError, InsufficientStockError, InvalidOrderParamsError };"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1494, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/Project%20OOPS%202/src/lib/auth.js"],"sourcesContent":["import jwt from \"jsonwebtoken\";\n\nexport function verifyToken(req) {\n  const auth = req.headers.authorization;\n  if (!auth) throw new Error(\"No token\");\n  const token = auth.split(\" \")[1];\n  return jwt.verify(token, process.env.JWT_SECRET);\n}\n"],"names":[],"mappings":";;;;AAAA;;AAEO,SAAS,YAAY,GAAG;IAC7B,MAAM,OAAO,IAAI,OAAO,CAAC,aAAa;IACtC,IAAI,CAAC,MAAM,MAAM,IAAI,MAAM;IAC3B,MAAM,QAAQ,KAAK,KAAK,CAAC,IAAI,CAAC,EAAE;IAChC,OAAO,4HAAG,CAAC,MAAM,CAAC,OAAO,QAAQ,GAAG,CAAC,UAAU;AACjD","debugId":null}},
    {"offset": {"line": 1510, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/Project%20OOPS%202/src/pages/api/wholesaler/orders/%5Bid%5D.js"],"sourcesContent":["// src/pages/api/wholesaler/orders/[id].js\r\nimport dbConnect from \"../../../../lib/dbConnect\";\r\nimport Order from \"../../../../models/orderModel\";\r\nimport OrderService from \"../../../../services/orderService\";\r\nimport { verifyToken } from \"../../../../lib/auth\";\r\nimport mongoose from \"mongoose\";\r\n\r\nexport default async function handler(req, res) {\r\n  await dbConnect();\r\n  \r\n  const { id: orderId } = req.query;\r\n\r\n  // --- 1. Authentication (Wholesaler) ---\r\n  let payload;\r\n  try {\r\n    payload = verifyToken(req);\r\n    if (!payload || payload.role !== \"WHOLESALER\") {\r\n      return res.status(401).json({ error: \"Unauthorized. You must be a Wholesaler.\" });\r\n    }\r\n  } catch (err) {\r\n    return res.status(401).json({ error: \"Unauthorized. Invalid token.\" });\r\n  }\r\n\r\n  const sellerId = new mongoose.Types.ObjectId(payload.id);\r\n\r\n  // --- 2. Handle PATCH Request ---\r\n  if (req.method === 'PATCH') {\r\n    try {\r\n      const { status } = req.body;\r\n      if (!status) return res.status(400).json({ error: \"New 'status' is required.\" });\r\n\r\n      // Security Check: Ensure order belongs to this wholesaler\r\n      const order = await Order.findById(orderId);\r\n      if (!order) return res.status(404).json({ error: \"Order not found.\" });\r\n\r\n      if (order.sellerId.toString() !== sellerId.toString()) {\r\n        return res.status(403).json({ error: \"Forbidden. You do not own this order.\" });\r\n      }\r\n\r\n      // Update status using service (handles stock restoration if cancelled)\r\n      const updatedOrder = await OrderService.updateStatus(orderId, status, { restoreStock: (status === 'cancelled') });\r\n      \r\n      return res.status(200).json({ order: updatedOrder });\r\n    } catch (err) {\r\n      console.error(err);\r\n      return res.status(400).json({ error: err.message || \"Failed to update order status.\" });\r\n    }\r\n  }\r\n\r\n  res.setHeader('Allow', ['PATCH']);\r\n  return res.status(405).end(`Method ${req.method} Not Allowed`);\r\n}   "],"names":[],"mappings":"AAAA,0CAA0C;;;;;AAC1C;AACA;AACA;AACA;AACA;;;;;;AAEe,eAAe,QAAQ,GAAG,EAAE,GAAG;IAC5C,MAAM,IAAA,2HAAS;IAEf,MAAM,EAAE,IAAI,OAAO,EAAE,GAAG,IAAI,KAAK;IAEjC,yCAAyC;IACzC,IAAI;IACJ,IAAI;QACF,UAAU,IAAA,0HAAW,EAAC;QACtB,IAAI,CAAC,WAAW,QAAQ,IAAI,KAAK,cAAc;YAC7C,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,OAAO;YAA0C;QACjF;IACF,EAAE,OAAO,KAAK;QACZ,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,OAAO;QAA+B;IACtE;IAEA,MAAM,WAAW,IAAI,oHAAQ,CAAC,KAAK,CAAC,QAAQ,CAAC,QAAQ,EAAE;IAEvD,kCAAkC;IAClC,IAAI,IAAI,MAAM,KAAK,SAAS;QAC1B,IAAI;YACF,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,IAAI;YAC3B,IAAI,CAAC,QAAQ,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,OAAO;YAA4B;YAE9E,0DAA0D;YAC1D,MAAM,QAAQ,MAAM,+HAAK,CAAC,QAAQ,CAAC;YACnC,IAAI,CAAC,OAAO,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,OAAO;YAAmB;YAEpE,IAAI,MAAM,QAAQ,CAAC,QAAQ,OAAO,SAAS,QAAQ,IAAI;gBACrD,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;oBAAE,OAAO;gBAAwC;YAC/E;YAEA,uEAAuE;YACvE,MAAM,eAAe,MAAM,mIAAY,CAAC,YAAY,CAAC,SAAS,QAAQ;gBAAE,cAAe,WAAW;YAAa;YAE/G,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,OAAO;YAAa;QACpD,EAAE,OAAO,KAAK;YACZ,QAAQ,KAAK,CAAC;YACd,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,OAAO,IAAI,OAAO,IAAI;YAAiC;QACvF;IACF;IAEA,IAAI,SAAS,CAAC,SAAS;QAAC;KAAQ;IAChC,OAAO,IAAI,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC,OAAO,EAAE,IAAI,MAAM,CAAC,YAAY,CAAC;AAC/D","debugId":null}}]
}