{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 22, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/untitled%20folder%20copy/src/lib/dbConnect.js"],"sourcesContent":["// lib/dbConnect.js\nimport mongoose from \"mongoose\";\n\n/**\n * @file dbConnect\n * @brief Reusable MongoDB connection util for Next.js API routes.\n *\n * Throws if MONGO_URI missing. Caches connection in global to avoid multiple\n * connections during hot-reload/development.\n */\n\nconst MONGO_URI = process.env.MONGO_URI;\nif (!MONGO_URI) throw new Error(\"MONGO_URI not set\");\n\nlet cached = global._mongoose || { conn: null, promise: null };\nif (!global._mongoose) global._mongoose = cached;\n\n/**\n * Ensure there is a single mongoose connection used across calls.\n * @returns {Promise<mongoose.Mongoose>}\n */\nexport default async function dbConnect() {\n  if (cached.conn) return cached.conn;\n  if (!cached.promise) {\n    // Use the connection string directly; options are managed by mongoose v8 defaults.\n    cached.promise = mongoose.connect(MONGO_URI).then(m => m);\n  }\n  cached.conn = await cached.promise;\n  return cached.conn;\n}\n"],"names":[],"mappings":"AAAA,mBAAmB;;;;;AACnB;;AAEA;;;;;;CAMC,GAED,MAAM,YAAY,QAAQ,GAAG,CAAC,SAAS;AACvC,IAAI,CAAC,WAAW,MAAM,IAAI,MAAM;AAEhC,IAAI,SAAS,yDAAO,SAAS,IAAI;IAAE,MAAM;IAAM,SAAS;AAAK;AAC7D,IAAI,CAAC,yDAAO,SAAS,EAAE,yDAAO,SAAS,GAAG;AAM3B,eAAe;IAC5B,IAAI,OAAO,IAAI,EAAE,OAAO,OAAO,IAAI;IACnC,IAAI,CAAC,OAAO,OAAO,EAAE;QACnB,mFAAmF;QACnF,OAAO,OAAO,GAAG,oHAAQ,CAAC,OAAO,CAAC,WAAW,IAAI,CAAC,CAAA,IAAK;IACzD;IACA,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;IAClC,OAAO,OAAO,IAAI;AACpB","debugId":null}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/untitled%20folder%20copy/src/models/orderModel.js"],"sourcesContent":["// models/orderModel.js\nimport mongoose from \"mongoose\";\n\nconst { Schema } = mongoose;\n\n/**\n * Minimal snapshot item schema used inside Order documents.\n * We intentionally store product name and unitPrice as snapshot values\n * to preserve historical pricing even if product changes later.\n */\nconst orderItemSchema = new Schema({\n  productId: { type: Schema.Types.ObjectId, ref: \"Product\", required: true },\n  name: { type: String, required: true },\n  sizeLabel: { type: String, required: true },\n  qty: { type: Number, required: true, min: 1 },\n  unitPrice: { type: Number, required: true },\n  subtotal: { type: Number, required: true },\n\n  // Optional per-item ETA (kept optional; useful if you want per-item arrival times)\n  estimatedDelivery: { type: Date }\n}, { _id: false });\n\n/**\n * Status history entries record all status transitions with timestamps and optional notes.\n * Keeping a history helps support audits, customer timeline view and notifications.\n */\nconst statusHistorySchema = new Schema({\n  status: { type: String, required: true },\n  at: { type: Date, default: Date.now },\n  note: { type: String }\n}, { _id: false });\n\nconst orderSchema = new Schema({\n  customer: {\n    name: { type: String, required: true },\n    email: { type: String },\n    phone: { type: String },\n    address: { type: String },\n    // optional structured location (if you put location here, createOrder will use it)\n    customerLocation: { type: Schema.Types.Mixed }\n  },\n  items: { type: [orderItemSchema], required: true },\n\n  subtotal: { type: Number, required: true },\n  shipping: { type: Number, default: 0 },\n  tax: { type: Number, default: 0 },\n  discount: { type: Number, default: 0 },\n  total: { type: Number, required: true },\n\n  /**\n   * Keep existing statuses and add explicit values used by the auto-advance flow.\n   * - 'created' kept for backwards compatibility\n   * - 'ordered' added for explicit placed state\n   * - 'out_for_delivery' added to represent \"out for delivery\"\n   */\n  status: {\n    type: String,\n    enum: [\n      \"created\",\n      \"ordered\",\n      \"pending\",\n      \"paid\",\n      \"processing\",\n      \"shipped\",\n      \"out_for_delivery\",\n      \"delivered\",\n      \"cancelled\",\n      \"refunded\"\n    ],\n    default: \"created\"\n  },\n\n  // status history to record every transition (ordered -> shipped -> out_for_delivery -> delivered, etc.)\n  statusHistory: { type: [statusHistorySchema], default: [] },\n\n  // order-wide estimated delivery date (aggregated across items)\n  estimatedDelivery: { type: Date },\n\n  payment: {\n    provider: { type: String },\n    paymentId: { type: String },\n    method: { type: String },\n    paidAt: { type: Date },\n    refundedAt: { type: Date },\n    refundInfo: { type: Schema.Types.Mixed }\n  },\n\n  fulfillment: {\n    trackingNumber: String,\n    carrier: String,\n    shippedAt: Date,\n    outForDeliveryAt: Date,\n    deliveredAt: Date\n  },\n\n  // convenience top-level timestamps (optional redundancy kept if your code references these)\n  shippedAt: Date,\n  outForDeliveryAt: Date,\n  deliveredAt: Date,\n\n  userId: { type: Schema.Types.ObjectId, ref: \"User\" },\n  meta: { type: Schema.Types.Mixed },\n  archived: { type: Boolean, default: false }\n}, { timestamps: true });\n\n// Useful indexes for listing and filtering orders\norderSchema.index({ userId: 1, createdAt: -1 });\norderSchema.index({ \"customer.email\": 1 });\norderSchema.index({ status: 1, createdAt: -1 });\n\nexport default mongoose.models.Order || mongoose.model(\"Order\", orderSchema);\n"],"names":[],"mappings":"AAAA,uBAAuB;;;;;AACvB;;AAEA,MAAM,EAAE,MAAM,EAAE,GAAG,oHAAQ;AAE3B;;;;CAIC,GACD,MAAM,kBAAkB,IAAI,OAAO;IACjC,WAAW;QAAE,MAAM,OAAO,KAAK,CAAC,QAAQ;QAAE,KAAK;QAAW,UAAU;IAAK;IACzE,MAAM;QAAE,MAAM;QAAQ,UAAU;IAAK;IACrC,WAAW;QAAE,MAAM;QAAQ,UAAU;IAAK;IAC1C,KAAK;QAAE,MAAM;QAAQ,UAAU;QAAM,KAAK;IAAE;IAC5C,WAAW;QAAE,MAAM;QAAQ,UAAU;IAAK;IAC1C,UAAU;QAAE,MAAM;QAAQ,UAAU;IAAK;IAEzC,mFAAmF;IACnF,mBAAmB;QAAE,MAAM;IAAK;AAClC,GAAG;IAAE,KAAK;AAAM;AAEhB;;;CAGC,GACD,MAAM,sBAAsB,IAAI,OAAO;IACrC,QAAQ;QAAE,MAAM;QAAQ,UAAU;IAAK;IACvC,IAAI;QAAE,MAAM;QAAM,SAAS,KAAK,GAAG;IAAC;IACpC,MAAM;QAAE,MAAM;IAAO;AACvB,GAAG;IAAE,KAAK;AAAM;AAEhB,MAAM,cAAc,IAAI,OAAO;IAC7B,UAAU;QACR,MAAM;YAAE,MAAM;YAAQ,UAAU;QAAK;QACrC,OAAO;YAAE,MAAM;QAAO;QACtB,OAAO;YAAE,MAAM;QAAO;QACtB,SAAS;YAAE,MAAM;QAAO;QACxB,mFAAmF;QACnF,kBAAkB;YAAE,MAAM,OAAO,KAAK,CAAC,KAAK;QAAC;IAC/C;IACA,OAAO;QAAE,MAAM;YAAC;SAAgB;QAAE,UAAU;IAAK;IAEjD,UAAU;QAAE,MAAM;QAAQ,UAAU;IAAK;IACzC,UAAU;QAAE,MAAM;QAAQ,SAAS;IAAE;IACrC,KAAK;QAAE,MAAM;QAAQ,SAAS;IAAE;IAChC,UAAU;QAAE,MAAM;QAAQ,SAAS;IAAE;IACrC,OAAO;QAAE,MAAM;QAAQ,UAAU;IAAK;IAEtC;;;;;GAKC,GACD,QAAQ;QACN,MAAM;QACN,MAAM;YACJ;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;SACD;QACD,SAAS;IACX;IAEA,wGAAwG;IACxG,eAAe;QAAE,MAAM;YAAC;SAAoB;QAAE,SAAS,EAAE;IAAC;IAE1D,+DAA+D;IAC/D,mBAAmB;QAAE,MAAM;IAAK;IAEhC,SAAS;QACP,UAAU;YAAE,MAAM;QAAO;QACzB,WAAW;YAAE,MAAM;QAAO;QAC1B,QAAQ;YAAE,MAAM;QAAO;QACvB,QAAQ;YAAE,MAAM;QAAK;QACrB,YAAY;YAAE,MAAM;QAAK;QACzB,YAAY;YAAE,MAAM,OAAO,KAAK,CAAC,KAAK;QAAC;IACzC;IAEA,aAAa;QACX,gBAAgB;QAChB,SAAS;QACT,WAAW;QACX,kBAAkB;QAClB,aAAa;IACf;IAEA,4FAA4F;IAC5F,WAAW;IACX,kBAAkB;IAClB,aAAa;IAEb,QAAQ;QAAE,MAAM,OAAO,KAAK,CAAC,QAAQ;QAAE,KAAK;IAAO;IACnD,MAAM;QAAE,MAAM,OAAO,KAAK,CAAC,KAAK;IAAC;IACjC,UAAU;QAAE,MAAM;QAAS,SAAS;IAAM;AAC5C,GAAG;IAAE,YAAY;AAAK;AAEtB,kDAAkD;AAClD,YAAY,KAAK,CAAC;IAAE,QAAQ;IAAG,WAAW,CAAC;AAAE;AAC7C,YAAY,KAAK,CAAC;IAAE,kBAAkB;AAAE;AACxC,YAAY,KAAK,CAAC;IAAE,QAAQ;IAAG,WAAW,CAAC;AAAE;uCAE9B,oHAAQ,CAAC,MAAM,CAAC,KAAK,IAAI,oHAAQ,CAAC,KAAK,CAAC,SAAS","debugId":null}},
    {"offset": {"line": 259, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/untitled%20folder%20copy/src/models/Product.js"],"sourcesContent":["// src/models/Product.js\nimport mongoose from \"mongoose\";\n\nconst { Schema } = mongoose;\n\n/**\n * Review subdocument\n * - rating: number (1..5)\n * - comment: string\n * - author: optional (retailer/customer id or name)\n * - createdAt\n */\nconst ReviewSchema = new Schema({\n  rating: { type: Number, required: true, min: 1, max: 5 },\n  comment: { type: String, default: \"\" },\n  author: { type: String }, // you can replace with ObjectId ref later\n  createdAt: { type: Date, default: Date.now },\n});\n\n/**\n * Size variant schema:\n * - size (S, M, L, XL, 6M etc.)\n * - sku (optional)\n * - stock (number)\n * - price override (optional)\n */\nconst SizeVariantSchema = new Schema({\n  size: { type: String, required: true },\n  sku: { type: String },\n  stock: { type: Number, default: 0 },\n  price: { type: Number }, // optional per-size price\n});\n\n/**\n * Size chart (generic object). Example:\n * { \"S\": { chest: \"...\", length: \"...\" }, ... }\n */\nconst SizeChartSchema = new Schema({\n  chartName: { type: String }, // e.g., \"Men's Hoodies\"\n  data: { type: Schema.Types.Mixed }, // flexible object with per-size measurements\n}, { _id: false });\n\n/**\n * Warehouse / storage location\n * retailers / wholesalers provide this\n */\nconst WarehouseSchema = new Schema({\n  name: { type: String }, // \"Chennai Warehouse\"\n  address: { type: String },\n  city: { type: String },\n  state: { type: String },\n  country: { type: String },\n  pincode: { type: String },\n  // approximate lead time (in days) from this warehouse to deliver locally\n  leadTimeDays: { type: Number, default: 2 },\n  // optional geo coords (if you want to compute distance later)\n  location: {\n    type: { type: String, enum: ['Point'], default: 'Point' },\n    coordinates: { type: [Number], default: undefined }, // [lng, lat]\n  },\n}, { _id: false });\n\n/**\n * Product details object (clothing attributes)\n */\nconst ProductDetailsSchema = new Schema({\n  materialComposition: { type: String }, // \"60% Cotton, 40% Polyester\"\n  sleeveType: { type: String }, // \"Long Sleeve\"\n  materialType: { type: String }, // \"Polycotton\"\n  fitType: { type: String }, // \"Regular\"\n  length: { type: String }, // \"Standard Length\"\n  neckStyle: { type: String }, // \"Hooded Neck\"\n  countryOfOrigin: { type: String }, // \"India\"\n  // allow extra props\n  extras: { type: Schema.Types.Mixed },\n}, { _id: false });\n\nconst ProductSchema = new Schema({\n  name: { type: String, required: true, index: true },\n  slug: { type: String, index: true }, // create slugs if needed\n  description: { type: String },\n  brand: { type: String },\n  retailer: { type: String },\n  category: { type: String },\n  price: { type: Number, required: true },\n  // multiple pictures (store URLs)\n  images: [{ type: String }],\n  // stock per variant (sizes)\n  sizes: [SizeVariantSchema],\n  sizeChart: SizeChartSchema,\n  productDetails: ProductDetailsSchema,\n  // reviews\n  reviews: [ReviewSchema],\n  // warehouses where the product is stored\n  warehouses: [WarehouseSchema],\n  // general inventory: totalStock (derived field)\n  totalStock: { type: Number, default: 0 },\n  // any tags or metadata\n  tags: [String],\n  createdAt: { type: Date, default: Date.now },\n  updatedAt: { type: Date, default: Date.now },\n}, { timestamps: true });\n\n/**\n * helper to recalc totalStock\n */\nProductSchema.methods.recalculateStock = function () {\n  const sizeStock = (this.sizes || []).reduce((acc, s) => acc + (s.stock || 0), 0);\n  // Optionally we could add warehouse counts; using size stock as source of truth\n  this.totalStock = sizeStock;\n  return this.totalStock;\n};\n\n/**\n * get best delivery estimate for a given customer location object:\n * { city, state, country, pincode }\n *\n * Simple approach used here:\n * - If there's a warehouse in same pincode => return warehouse.leadTimeDays (fastest)\n * - else if same city => warehouse.leadTimeDays + 1\n * - else if same state => warehouse.leadTimeDays + 2\n * - else => warehouse.leadTimeDays + 4\n *\n * (This is a placeholder algorithm — you can replace with distance or courier API)\n */\nProductSchema.methods.estimateDeliveryTo = function (customerLocation = {}) {\n  const whs = this.warehouses || [];\n  if (!whs.length) return { estimatedDays: null, reason: \"no warehouses configured\" };\n\n  // find exact pincode match\n  const byPincode = whs.find(w => w.pincode && customerLocation.pincode && w.pincode === customerLocation.pincode);\n  if (byPincode) {\n    return { estimatedDays: byPincode.leadTimeDays, warehouse: byPincode, method: \"pincode-match\" };\n  }\n\n  // same city\n  const byCity = whs.find(w => w.city && customerLocation.city && w.city.toLowerCase() === customerLocation.city.toLowerCase());\n  if (byCity) {\n    return { estimatedDays: byCity.leadTimeDays + 1, warehouse: byCity, method: \"city-match\" };\n  }\n\n  // same state\n  const byState = whs.find(w => w.state && customerLocation.state && w.state.toLowerCase() === customerLocation.state.toLowerCase());\n  if (byState) {\n    return { estimatedDays: byState.leadTimeDays + 2, warehouse: byState, method: \"state-match\" };\n  }\n\n  // fallback: pick warehouse with smallest leadTimeDays and add generic shipping\n  const minWh = whs.reduce((min, w) => (!min || (w.leadTimeDays < min.leadTimeDays) ? w : min), null);\n  return { estimatedDays: (minWh ? minWh.leadTimeDays + 4 : null), warehouse: minWh, method: \"fallback\" };\n};\n\nexport default mongoose.models.Product || mongoose.model(\"Product\", ProductSchema);\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 535, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/untitled%20folder%20copy/src/services/inventory.js"],"sourcesContent":["// src/services/inventory.js\nimport Product from \"models/Product.js\";\n\n/**\n * @file InventoryService\n * @brief Centralized product stock operations (sizes array).\n *\n * Responsibilities:\n *  - Single-item atomic updates (increaseStock, decreaseStock)\n *  - Multi-item transactional decrement (decreaseStockForItems)\n *  - Safe helpers for adding sizes, checking stock, and total stock\n *\n * Notes:\n *  - We use runValidators: true on updateOne to enforce schema constraints\n *    such as min: 0 on size.stock.\n *  - After each decrement we read back the value and throw if stock is negative\n *    so callers (inside transactions) can abort and avoid persisted negative values.\n */\n\n/** Base error for inventory operations */\nclass InventoryError extends Error {}\n/** Thrown when requested qty cannot be satisfied */\nclass InsufficientStockError extends InventoryError {}\n/** Thrown when input params are invalid */\nclass InvalidParamsError extends InventoryError {}\n\nexport default class InventoryService {\n  /**\n   * Normalize size label defensively.\n   * @private\n   * @param {any} sizeLabel\n   * @returns {string}\n   */\n  static _normalizeLabel(sizeLabel) {\n    return sizeLabel === undefined || sizeLabel === null ? \"\" : String(sizeLabel).trim();\n  }\n\n  /**\n   * Validate and normalize params for single-item operations.\n   * Throws InvalidParamsError on invalid input.\n   * @private\n   * @param {String|ObjectId} productId\n   * @param {String} sizeLabel\n   * @param {Number} qty\n   * @returns {{productId:*, sizeLabel:string, qty:number}}\n   */\n  static _validateParams(productId, sizeLabel, qty) {\n    if (!productId) throw new InvalidParamsError(\"productId is required\");\n    const label = this._normalizeLabel(sizeLabel);\n    if (!label) throw new InvalidParamsError(\"sizeLabel is required\");\n    const q = Number(qty);\n    if (!Number.isFinite(q) || q <= 0) throw new InvalidParamsError(\"qty must be a positive number\");\n    return { productId, sizeLabel: label, qty: Math.floor(q) };\n  }\n\n  /**\n   * Decrease stock for a specific product size by qty.\n   * If a mongoose session is provided, the update participates in the transaction.\n   * Uses runValidators to ensure schema constraints (min:0) are enforced.\n   * @param {String|ObjectId} productId\n   * @param {String} sizeLabel\n   * @param {Number} qty\n   * @param {mongoose.ClientSession} [session]\n   * @returns {Promise<boolean>} true if modified, throws InsufficientStockError otherwise\n   * @throws {InvalidParamsError|InsufficientStockError}\n   */\n  static async decreaseStock(productId, sizeLabel, qty, session = null) {\n    const params = this._validateParams(productId, sizeLabel, qty);\n\n    const filter = {\n      _id: params.productId,\n      \"sizes.size\": params.sizeLabel,\n      \"sizes.stock\": { $gte: params.qty }\n    };\n\n    const update = { $inc: { \"sizes.$[el].stock\": -params.qty } };\n    // include runValidators to enforce schema min:0\n    const options = { arrayFilters: [{ \"el.size\": params.sizeLabel }], runValidators: true };\n    if (session) options.session = session;\n\n    const res = await Product.updateOne(filter, update, options);\n    const modified = (res.modifiedCount ?? res.nModified ?? 0) > 0;\n\n    if (!modified) {\n      // fetch current available stock for better error message\n      const current = await Product.findOne(\n        { _id: params.productId, \"sizes.size\": params.sizeLabel },\n        { \"sizes.$\": 1 }\n      ).session(session).lean();\n\n      const available = current && current.sizes && current.sizes[0] ? Number(current.sizes[0].stock || 0) : 0;\n      throw new InsufficientStockError(`Insufficient stock for product ${params.productId} size ${params.sizeLabel}. Requested ${params.qty}, available ${available}`);\n    }\n\n    // defensive post-check: ensure new stock is not negative\n    const post = await Product.findOne(\n      { _id: params.productId, \"sizes.size\": params.sizeLabel },\n      { \"sizes.$\": 1 }\n    ).session(session).lean();\n\n    const newStock = post && post.sizes && post.sizes[0] ? Number(post.sizes[0].stock || 0) : 0;\n    if (newStock < 0) {\n      throw new InsufficientStockError(`Post-update stock negative (${newStock}) for product ${params.productId} size ${params.sizeLabel}`);\n    }\n\n    return true;\n  }\n\n  /**\n   * Increase stock for a specific product size by qty (restock/cancel).\n   * Returns true if an existing size was updated, false if not found (size missing).\n   * Use addOrCreateSize to add a missing size.\n   * @param {String|ObjectId} productId\n   * @param {String} sizeLabel\n   * @param {Number} qty\n   * @param {mongoose.ClientSession} [session]\n   * @returns {Promise<boolean>}\n   */\n  static async increaseStock(productId, sizeLabel, qty, session = null) {\n    const params = this._validateParams(productId, sizeLabel, qty);\n\n    const filter = { _id: params.productId, \"sizes.size\": params.sizeLabel };\n    const update = { $inc: { \"sizes.$[el].stock\": params.qty } };\n    const options = { arrayFilters: [{ \"el.size\": params.sizeLabel }], runValidators: true };\n    if (session) options.session = session;\n\n    const res = await Product.updateOne(filter, update, options);\n    const modified = (res.modifiedCount ?? res.nModified ?? 0) > 0;\n\n    if (modified) {\n      // post-check to ensure validators didn't allow a bad state\n      const post = await Product.findOne(\n        { _id: params.productId, \"sizes.size\": params.sizeLabel },\n        { \"sizes.$\": 1 }\n      ).session(session).lean();\n      const newStock = post && post.sizes && post.sizes[0] ? Number(post.sizes[0].stock || 0) : 0;\n      if (newStock < 0) {\n        throw new InventoryError(`Post-increase stock negative (${newStock}) for product ${params.productId} size ${params.sizeLabel}`);\n      }\n      return true;\n    }\n\n    // size missing -> return false to let callers add/create\n    return false;\n  }\n\n  /**\n   * Add a new size entry if it doesn't exist, or set the stock if it does.\n   * @param {String|ObjectId} productId\n   * @param {String} sizeLabel\n   * @param {Number} qty\n   * @param {mongoose.ClientSession} [session]\n   * @returns {Promise<void>}\n   * @throws {InvalidParamsError}\n   */\n  static async addOrCreateSize(productId, sizeLabel, qty = 0, session = null) {\n    if (!productId) throw new InvalidParamsError(\"productId is required\");\n    const label = this._normalizeLabel(sizeLabel);\n    if (!label) throw new InvalidParamsError(\"sizeLabel is required\");\n    const q = Math.max(0, Math.floor(Number(qty) || 0));\n    const options = { arrayFilters: [{ \"el.size\": label }], runValidators: true };\n    if (session) options.session = session;\n\n    // Try update first; if not matched, push a new size\n    const res = await Product.updateOne(\n      { _id: productId, \"sizes.size\": label },\n      { $set: { \"sizes.$[el].stock\": q } },\n      options\n    );\n\n    if ((res.modifiedCount ?? res.nModified ?? 0) === 0) {\n      await Product.updateOne(\n        { _id: productId },\n        { $push: { sizes: { size: label, stock: q } } },\n        session ? { session } : {}\n      );\n    }\n  }\n\n  /**\n   * Get stock for a specific size. Returns 0 if product or size not found.\n   * @param {String|ObjectId} productId\n   * @param {String} sizeLabel\n   * @returns {Promise<number>}\n   */\n  static async getStock(productId, sizeLabel) {\n    if (!productId) throw new InvalidParamsError(\"productId is required\");\n    const label = this._normalizeLabel(sizeLabel);\n    if (!label) throw new InvalidParamsError(\"sizeLabel is required\");\n\n    const doc = await Product.findById(productId, { sizes: 1 }).lean();\n    if (!doc || !Array.isArray(doc.sizes)) return 0;\n    const s = doc.sizes.find(x => String(x.size).trim() === label);\n    return s ? Number(s.stock || 0) : 0;\n  }\n\n  /**\n   * Returns total stock across all sizes for the product (integer).\n   * @param {String|ObjectId} productId\n   * @returns {Promise<number>}\n   */\n  static async totalStock(productId) {\n    if (!productId) throw new InvalidParamsError(\"productId is required\");\n    const doc = await Product.findById(productId, { sizes: 1 }).lean();\n    if (!doc || !Array.isArray(doc.sizes)) return 0;\n    return doc.sizes.reduce((sum, s) => sum + Math.max(0, Number(s.stock || 0)), 0);\n  }\n\n  /**\n   * Decrease stock for multiple items inside a session/transaction.\n   * This method expects a mongoose session that has had startTransaction called.\n   * It will throw InsufficientStockError if any individual decrement cannot be applied.\n   *\n   * @param {Array<{productId: string, sizeLabel: string, qty: number}>} items\n   * @param {mongoose.ClientSession} session - required\n   * @returns {Promise<void>}\n   * @throws {InvalidParamsError|InsufficientStockError}\n   */\n  static async decreaseStockForItems(items = [], session) {\n    if (!Array.isArray(items) || items.length === 0) return;\n    if (!session) throw new InvalidParamsError(\"A mongoose session is required for multi-item decrease\");\n\n    // Validate items and normalize labels\n    for (const it of items) {\n      it.sizeLabel = this._normalizeLabel(it.sizeLabel);\n      this._validateParams(it.productId, it.sizeLabel, it.qty);\n    }\n\n    // Attempt each update; on failure fetch available and throw InsufficientStockError\n    for (const it of items) {\n      const updated = await Product.updateOne(\n        {\n          _id: it.productId,\n          \"sizes.size\": it.sizeLabel,\n          \"sizes.stock\": { $gte: it.qty }\n        },\n        { $inc: { \"sizes.$[el].stock\": -it.qty } },\n        { arrayFilters: [{ \"el.size\": it.sizeLabel }], session, runValidators: true }\n      );\n\n      const modified = (updated.modifiedCount ?? updated.nModified ?? 0) > 0;\n      if (!modified) {\n        const current = await Product.findOne(\n          { _id: it.productId, \"sizes.size\": it.sizeLabel },\n          { \"sizes.$\": 1 }\n        ).session(session).lean();\n\n        const available = current && current.sizes && current.sizes[0] ? Number(current.sizes[0].stock || 0) : 0;\n        throw new InsufficientStockError(\n          `Insufficient stock for product ${it.productId} size ${it.sizeLabel}. Requested ${it.qty}, available ${available}`\n        );\n      }\n\n      // post-check\n      const post = await Product.findOne(\n        { _id: it.productId, \"sizes.size\": it.sizeLabel },\n        { \"sizes.$\": 1 }\n      ).session(session).lean();\n\n      const newStock = post && post.sizes && post.sizes[0] ? Number(post.sizes[0].stock || 0) : 0;\n      if (newStock < 0) {\n        throw new InsufficientStockError(\n          `Post-update stock negative (${newStock}) for product ${it.productId} size ${it.sizeLabel}`\n        );\n      }\n    }\n    // all decrements succeeded (still inside caller's transaction)\n  }\n}\n\n// Export error classes for callers that want to check error types.\nexport { InventoryError, InsufficientStockError, InvalidParamsError };\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 848, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/untitled%20folder%20copy/src/services/orderService.js"],"sourcesContent":["// src/services/orderService.js\nimport mongoose from \"mongoose\";\nimport Order from \"models/orderModel.js\";\nimport Product from \"models/Product.js\";\nimport InventoryService, { InsufficientStockError as InvInsufficientStockError } from \"./inventory.js\";\n\n/**\n * @file OrderService\n * @brief Order creation and lifecycle helpers (get, list, status updates, refunds).\n *\n * This service coordinates with InventoryService for stock changes and uses\n * mongoose transactions to ensure atomic operations when modifying inventory\n * and orders together.\n */\n\n/** Base order error */\nclass OrderError extends Error {}\n/** Thrown when stock cannot be satisfied during create/update */\nclass InsufficientStockError extends OrderError {}\n/** Thrown when invalid input supplied */\nclass InvalidOrderParamsError extends OrderError {}\n\nexport default class OrderService {\n  /**\n   * Create an order atomically: validates items, decrements stock, and saves order doc.\n   *\n   * On success the saved Mongoose Order document is returned.\n   *\n   * @param {Object} customer - { name, email, phone, address, customerLocation? }\n   * @param {Array<{productId, sizeLabel, qty}>} items\n   * @returns {Promise<Object>} saved Mongoose Order document\n   * @throws {OrderError|InsufficientStockError|Error}\n   */\n  static async createOrder(customer = {}, items = []) {\n    if (!Array.isArray(items) || items.length === 0) {\n      throw new OrderError(\"Order must contain at least one item\");\n    }\n\n    const session = await mongoose.startSession();\n    try {\n      session.startTransaction();\n\n      // 1) Load product docs for all requested items (inside session) as model instances (no .lean())\n      const productIds = [...new Set(items.map(i => String(i.productId)))];\n      const products = await Product.find({ _id: { $in: productIds } }).session(session);\n      const productMap = new Map(products.map(p => [String(p._id), p]));\n\n      // 2) Build order items with snapshots and validation\n      const orderItems = [];\n      for (const it of items) {\n        const pid = String(it.productId);\n        const doc = productMap.get(pid);\n        if (!doc) {\n          throw new OrderError(`Product not found: ${pid}`);\n        }\n\n        const qty = Math.max(0, Math.floor(Number(it.qty || 0)));\n        if (qty <= 0) throw new OrderError(`Invalid quantity for product ${pid}`);\n\n        const size = Array.isArray(doc.sizes) ? doc.sizes.find(s => s.size === it.sizeLabel || s.size === it.size) : null;\n        if (!size) throw new OrderError(`Size '${it.sizeLabel}' not found for product ${pid}`);\n\n        const unitPrice = Number(size?.price ?? doc.price ?? 0);\n        const subtotal = unitPrice * qty;\n\n        orderItems.push({\n          productId: doc._id,\n          name: doc.name,\n          sizeLabel: it.sizeLabel,\n          qty,\n          unitPrice,\n          subtotal\n          // per-item estimatedDelivery will be added later if available\n        });\n      }\n\n      // 3) Attempt multi-item atomic stock decrement using InventoryService (throws on insufficient)\n      const inventoryItems = items.map(i => ({ productId: i.productId, sizeLabel: i.sizeLabel, qty: i.qty }));\n      await InventoryService.decreaseStockForItems(inventoryItems, session);\n\n      // 4) Calculate totals\n      const subtotal = orderItems.reduce((s, it) => s + (it.subtotal || 0), 0);\n      const shipping = 0;\n      const tax = 0;\n      const discount = 0;\n      const total = subtotal + shipping + tax - discount;\n\n      // ----------------------------\n      // Compute estimated delivery\n      // ----------------------------\n      // Use the Product instance method estimateDeliveryTo(customerLocation) if available.\n      const customerLocation = (customer && (customer.customerLocation || customer.location)) || {};\n      const perItemEstimates = [];\n\n      for (let idx = 0; idx < orderItems.length; idx++) {\n        const it = orderItems[idx];\n        const prod = productMap.get(String(it.productId));\n        if (!prod) continue;\n\n        try {\n          // product.estimateDeliveryTo may be sync or async; await works for either\n          const raw = await prod.estimateDeliveryTo(customerLocation || {});\n          if (raw) {\n            const date = raw instanceof Date ? raw : new Date(raw);\n            if (!isNaN(date.getTime())) {\n              perItemEstimates.push(date);\n              // store per-item ETA on the snapshot (optional but useful)\n              it.estimatedDelivery = date;\n            }\n          }\n        } catch (e) {\n          // ignore individual product estimator errors — preserve order creation\n          console.warn(`estimateDeliveryTo failed for product ${prod._id}:`, e && e.message);\n        }\n      }\n\n      // Aggregate: choose latest date so order ETA covers all items.\n      let estimatedDelivery = null;\n      if (perItemEstimates.length > 0) {\n        estimatedDelivery = new Date(Math.max(...perItemEstimates.map(d => d.getTime())));\n      } else {\n        // fallback default (5 days)\n        estimatedDelivery = new Date(Date.now() + 5 * 24 * 60 * 60 * 1000);\n      }\n\n      // 5) Create order doc (inside same transaction) with statusHistory and ETA\n      const now = new Date();\n      const initialStatus = \"ordered\"; // set to 'ordered' to reflect placed order\n      const orderDoc = new Order({\n        customer,\n        items: orderItems,\n        subtotal,\n        shipping,\n        tax,\n        discount,\n        total,\n        status: initialStatus,\n        statusHistory: [{ status: initialStatus, at: now, note: \"Order placed\" }],\n        estimatedDelivery\n      });\n\n      const saved = await orderDoc.save({ session });\n\n      await session.commitTransaction();\n      session.endSession();\n\n      return saved;\n    } catch (err) {\n      try {\n        await session.abortTransaction();\n      } catch (_) {}\n      session.endSession();\n\n      // Map inventory error to domain-level InsufficientStockError\n      if (err && (err.name === \"InsufficientStockError\" || err instanceof InvInsufficientStockError)) {\n        throw new InsufficientStockError(err.message);\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * List orders with optional userId filter and pagination.\n   * @param {Object} opts\n   * @param {String} [opts.userId]\n   * @param {number} [opts.page=1]\n   * @param {number} [opts.limit=20]\n   * @returns {Promise<{items:Object[], total:number, page:number, limit:number}>}\n   */\n  static async listOrders({ userId, page = 1, limit = 20 } = {}) {\n    const filter = {};\n    if (userId) filter.userId = userId;\n    const skip = Math.max(0, (Number(page) - 1) * Number(limit));\n    const items = await Order.find(filter).sort({ createdAt: -1 }).skip(skip).limit(Number(limit)).lean();\n    const total = await Order.countDocuments(filter);\n    return { items, total, page: Number(page), limit: Number(limit) };\n  }\n\n  /**\n   * Get a single order by id.\n   * @param {String} id - Order ObjectId/string\n   * @returns {Promise<Object|null>}\n   */\n  static async getById(id) {\n    if (!id) throw new InvalidOrderParamsError(\"Order id is required\");\n    const doc = await Order.findById(id).lean();\n    return doc || null;\n  }\n\n  /**\n   * Internal helper: restore stock for an order's items inside a session.\n   * If a product size doesn't exist, it will be created with the restored qty.\n   *\n   * @private\n   * @param {Object[]} items - order items array (having productId, sizeLabel, qty)\n   * @param {mongoose.ClientSession} session\n   */\n  static async _restoreStockForItems(items = [], session) {\n    if (!Array.isArray(items) || items.length === 0) return;\n    if (!session) throw new InvalidOrderParamsError(\"A mongoose session is required for restore\");\n\n    // For each item: attempt increaseStock; if increaseStock returns false (size missing) use addOrCreateSize then increaseStock\n    for (const it of items) {\n      const productId = it.productId;\n      const sizeLabel = it.sizeLabel;\n      const qty = it.qty;\n\n      // attempt to increase (if size exists)\n      const increased = await InventoryService.increaseStock(productId, sizeLabel, qty, session);\n      if (!increased) {\n        // ensure size exists and set stock (preserve existing behavior)\n        await InventoryService.addOrCreateSize(productId, sizeLabel, qty, session);\n      }\n    }\n  }\n\n  /**\n   * Update the status of an order. Optionally restore stock when transitioning to cancelled/refunded.\n   *\n   * This method now appends a statusHistory entry automatically for every transition.\n   *\n   * @param {String} id - order id\n   * @param {String} newStatus - one of orderSchema enum statuses\n   * @param {Object} [opts]\n   * @param {Boolean} [opts.restoreStock=false] - when true and transitioning to cancelled/refunded, restores stock\n   * @returns {Promise<Object>} updated order document\n   * @throws {OrderError|InsufficientStockError|Error}\n   */\n  static async updateStatus(id, newStatus, { restoreStock = false } = {}) {\n    if (!id) throw new InvalidOrderParamsError(\"Order id is required\");\n    if (!newStatus || typeof newStatus !== \"string\") throw new InvalidOrderParamsError(\"newStatus is required\");\n\n    const VALID_STATUSES = [\"created\",\"ordered\",\"pending\",\"paid\",\"processing\",\"shipped\",\"out_for_delivery\",\"delivered\",\"cancelled\",\"refunded\"];\n    if (!VALID_STATUSES.includes(newStatus)) {\n      throw new InvalidOrderParamsError(`Invalid status: ${newStatus}`);\n    }\n\n    const session = await mongoose.startSession();\n    try {\n      session.startTransaction();\n\n      const order = await Order.findById(id).session(session);\n      if (!order) throw new OrderError(\"Order not found\");\n\n      const prevStatus = order.status;\n\n      // restore stock if requested and moving to cancelled/refunded\n      const shouldRestore = restoreStock && (newStatus === \"cancelled\" || newStatus === \"refunded\");\n      if (shouldRestore) {\n        await OrderService._restoreStockForItems(order.items, session);\n      }\n\n      // set status and append to statusHistory\n      const now = new Date();\n      order.status = newStatus;\n      order.statusHistory = order.statusHistory || [];\n      order.statusHistory.push({\n        status: newStatus,\n        at: now,\n        note: `Status changed from ${prevStatus} to ${newStatus}`\n      });\n\n      // Set fulfillment/top-level timestamps where relevant\n      if (newStatus === \"shipped\") {\n        order.fulfillment = order.fulfillment || {};\n        order.fulfillment.shippedAt = order.fulfillment.shippedAt || now;\n        order.shippedAt = order.shippedAt || now;\n      } else if (newStatus === \"out_for_delivery\") {\n        order.fulfillment = order.fulfillment || {};\n        order.fulfillment.outForDeliveryAt = order.fulfillment.outForDeliveryAt || now;\n        order.outForDeliveryAt = order.outForDeliveryAt || now;\n      } else if (newStatus === \"delivered\") {\n        order.fulfillment = order.fulfillment || {};\n        order.fulfillment.deliveredAt = order.fulfillment.deliveredAt || now;\n        order.deliveredAt = order.deliveredAt || now;\n      } else if (newStatus === \"refunded\") {\n        order.payment = order.payment || {};\n        order.payment.refundedAt = order.payment.refundedAt || now;\n        order.payment.refundInfo = order.payment.refundInfo || {};\n        // keep meta/refund trace as well\n        order.meta = order.meta || {};\n        order.meta.refund = Object.assign({}, order.meta.refund || {}, { at: now });\n      }\n\n      const saved = await order.save({ session });\n\n      await session.commitTransaction();\n      session.endSession();\n\n      return saved;\n    } catch (err) {\n      try {\n        await session.abortTransaction();\n      } catch (_) {}\n      session.endSession();\n\n      if (err && (err.name === \"InsufficientStockError\" || err instanceof InvInsufficientStockError)) {\n        throw new InsufficientStockError(err.message);\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Process a refund for an order id.\n   *\n   * Behavior:\n   *  - marks order.status = 'refunded'\n   *  - optionally restores stock (default true)\n   *  - records refund metadata in payment.refundInfo and meta.refund\n   *\n   * NOTE: actual payment-provider refund must be orchestrated outside or before calling this,\n   * this method only reflects refund in DB and inventory.\n   *\n   * @param {String} id - order id\n   * @param {Object} [opts]\n   * @param {Boolean} [opts.restoreStock=true]\n   * @param {Object} [opts.refundInfo] - arbitrary refund metadata (provider, refundId, amount, note)\n   * @returns {Promise<Object>} updated order document\n   * @throws {OrderError|InsufficientStockError|Error}\n   */\n  static async refundOrder(id, { restoreStock = true, refundInfo = {} } = {}) {\n    if (!id) throw new InvalidOrderParamsError(\"Order id is required\");\n\n    const session = await mongoose.startSession();\n    try {\n      session.startTransaction();\n\n      const order = await Order.findById(id).session(session);\n      if (!order) throw new OrderError(\"Order not found\");\n\n      if (order.status === \"refunded\") {\n        // already refunded; nothing to do\n        await session.commitTransaction();\n        session.endSession();\n        return order;\n      }\n\n      // Restore stock before marking refunded\n      if (restoreStock) {\n        await OrderService._restoreStockForItems(order.items, session);\n      }\n\n      // Mark payment/refund metadata and status\n      const now = new Date();\n      order.status = \"refunded\";\n      order.statusHistory = order.statusHistory || [];\n      order.statusHistory.push({\n        status: \"refunded\",\n        at: now,\n        note: \"Order refunded\"\n      });\n\n      order.payment = order.payment || {};\n      order.payment.refundInfo = Object.assign({}, order.payment.refundInfo || {}, refundInfo);\n      order.payment.refundedAt = order.payment.refundedAt || now;\n\n      // also keep refund trace in meta\n      order.meta = order.meta || {};\n      order.meta.refund = Object.assign({}, order.meta.refund || {}, { at: now, info: refundInfo });\n\n      const saved = await order.save({ session });\n\n      await session.commitTransaction();\n      session.endSession();\n\n      return saved;\n    } catch (err) {\n      try {\n        await session.abortTransaction();\n      } catch (_) {}\n      session.endSession();\n\n      if (err && (err.name === \"InsufficientStockError\" || err instanceof InvInsufficientStockError)) {\n        throw new InsufficientStockError(err.message);\n      }\n      throw err;\n    }\n  }\n\n  // TODO: additional helpers such as `getOrdersByUser`, `archiveOrder`, `partialRefund`, etc.\n}\n\n// export error classes for callers\nexport { OrderError, InsufficientStockError, InvalidOrderParamsError };\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1237, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/untitled%20folder%20copy/src/pages/api/orders/%5Bid%5D.js"],"sourcesContent":["// src/pages/api/orders/[id].js\nimport dbConnect from \"lib/dbConnect.js\";\nimport OrderService from \"services/orderService.js\";\n\n/**\n * GET  /api/orders/:id    -> returns order\n * PATCH /api/orders/:id  -> update status, small edits\n */\nexport default async function handler(req, res) {\n  try { await dbConnect(); } catch (err) {\n    console.error(\"DB connect failed:\", err);\n    return res.status(500).json({ error: \"Database connection failed\" });\n  }\n\n  const { id } = req.query;\n\n  if (req.method === \"GET\") {\n    try {\n      const order = await OrderService.getById(id);\n      if (!order) return res.status(404).json({ error: \"Order not found\" });\n      return res.status(200).json(order);\n    } catch (err) {\n      console.error(\"GET /api/orders/[id] error:\", err);\n      return res.status(500).json({ error: err.message || \"Failed to fetch order\" });\n    }\n  }\n\n  if (req.method === \"PATCH\") {\n    try {\n      const { status, restoreStock = false, fulfillment, payment, meta } = req.body || {};\n      if (!status) return res.status(400).json({ error: \"status is required\" });\n\n      // support optional metadata updates later (fulfillment/payment) by the service if needed\n      const updated = await OrderService.updateStatus(id, status, { restoreStock });\n      // Merge optional small updates (tracking number etc.) by refetch+patch if provided\n      if ((fulfillment && Object.keys(fulfillment).length) || (payment && Object.keys(payment).length) || meta) {\n        // simple naive patch: get by id and assign fields then save via the model through OrderService.getById + model save\n        // To keep separation of concerns we return updated and let frontend call dedicated endpoints for deeper edits.\n      }\n\n      return res.status(200).json(updated);\n    } catch (err) {\n      console.error(\"PATCH /api/orders/[id] error:\", err);\n      if (err.name === \"InsufficientStockError\") return res.status(409).json({ error: err.message });\n      if (err.name === \"InvalidOrderParamsError\" || err.name === \"OrderError\") return res.status(400).json({ error: err.message });\n      return res.status(500).json({ error: err.message || \"Failed to update order status\" });\n    }\n  }\n\n  res.setHeader(\"Allow\", [\"GET\", \"PATCH\"]);\n  return res.status(405).end(`Method ${req.method} Not Allowed`);\n}\n"],"names":[],"mappings":"AAAA,+BAA+B;;;;;AAC/B;AACA;;;AAMe,eAAe,QAAQ,GAAG,EAAE,GAAG;IAC5C,IAAI;QAAE,MAAM,IAAA,2HAAS;IAAI,EAAE,OAAO,KAAK;QACrC,QAAQ,KAAK,CAAC,sBAAsB;QACpC,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,OAAO;QAA6B;IACpE;IAEA,MAAM,EAAE,EAAE,EAAE,GAAG,IAAI,KAAK;IAExB,IAAI,IAAI,MAAM,KAAK,OAAO;QACxB,IAAI;YACF,MAAM,QAAQ,MAAM,mIAAY,CAAC,OAAO,CAAC;YACzC,IAAI,CAAC,OAAO,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,OAAO;YAAkB;YACnE,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;QAC9B,EAAE,OAAO,KAAK;YACZ,QAAQ,KAAK,CAAC,+BAA+B;YAC7C,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,OAAO,IAAI,OAAO,IAAI;YAAwB;QAC9E;IACF;IAEA,IAAI,IAAI,MAAM,KAAK,SAAS;QAC1B,IAAI;YACF,MAAM,EAAE,MAAM,EAAE,eAAe,KAAK,EAAE,WAAW,EAAE,OAAO,EAAE,IAAI,EAAE,GAAG,IAAI,IAAI,IAAI,CAAC;YAClF,IAAI,CAAC,QAAQ,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,OAAO;YAAqB;YAEvE,yFAAyF;YACzF,MAAM,UAAU,MAAM,mIAAY,CAAC,YAAY,CAAC,IAAI,QAAQ;gBAAE;YAAa;YAC3E,mFAAmF;YACnF,IAAI,AAAC,eAAe,OAAO,IAAI,CAAC,aAAa,MAAM,IAAM,WAAW,OAAO,IAAI,CAAC,SAAS,MAAM,IAAK,MAAM;YACxG,oHAAoH;YACpH,+GAA+G;YACjH;YAEA,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;QAC9B,EAAE,OAAO,KAAK;YACZ,QAAQ,KAAK,CAAC,iCAAiC;YAC/C,IAAI,IAAI,IAAI,KAAK,0BAA0B,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,OAAO,IAAI,OAAO;YAAC;YAC5F,IAAI,IAAI,IAAI,KAAK,6BAA6B,IAAI,IAAI,KAAK,cAAc,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,OAAO,IAAI,OAAO;YAAC;YAC1H,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,OAAO,IAAI,OAAO,IAAI;YAAgC;QACtF;IACF;IAEA,IAAI,SAAS,CAAC,SAAS;QAAC;QAAO;KAAQ;IACvC,OAAO,IAAI,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC,OAAO,EAAE,IAAI,MAAM,CAAC,YAAY,CAAC;AAC/D","debugId":null}}]
}