{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 22, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/untitled%20folder/src/lib/dbConnect.js"],"sourcesContent":["// lib/dbConnect.js\nimport mongoose from \"mongoose\";\n\n/**\n * @file dbConnect\n * @brief Reusable MongoDB connection util for Next.js API routes.\n *\n * Throws if MONGO_URI missing. Caches connection in global to avoid multiple\n * connections during hot-reload/development.\n */\n\nconst MONGO_URI = process.env.MONGO_URI;\nif (!MONGO_URI) throw new Error(\"MONGO_URI not set\");\n\nlet cached = global._mongoose || { conn: null, promise: null };\nif (!global._mongoose) global._mongoose = cached;\n\n/**\n * Ensure there is a single mongoose connection used across calls.\n * @returns {Promise<mongoose.Mongoose>}\n */\nexport default async function dbConnect() {\n  if (cached.conn) return cached.conn;\n  if (!cached.promise) {\n    // Use the connection string directly; options are managed by mongoose v8 defaults.\n    cached.promise = mongoose.connect(MONGO_URI).then(m => m);\n  }\n  cached.conn = await cached.promise;\n  return cached.conn;\n}\n"],"names":[],"mappings":"AAAA,mBAAmB;;;;;AACnB;;AAEA;;;;;;CAMC,GAED,MAAM,YAAY,QAAQ,GAAG,CAAC,SAAS;AACvC,IAAI,CAAC,WAAW,MAAM,IAAI,MAAM;AAEhC,IAAI,SAAS,yDAAO,SAAS,IAAI;IAAE,MAAM;IAAM,SAAS;AAAK;AAC7D,IAAI,CAAC,yDAAO,SAAS,EAAE,yDAAO,SAAS,GAAG;AAM3B,eAAe;IAC5B,IAAI,OAAO,IAAI,EAAE,OAAO,OAAO,IAAI;IACnC,IAAI,CAAC,OAAO,OAAO,EAAE;QACnB,mFAAmF;QACnF,OAAO,OAAO,GAAG,oHAAQ,CAAC,OAAO,CAAC,WAAW,IAAI,CAAC,CAAA,IAAK;IACzD;IACA,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;IAClC,OAAO,OAAO,IAAI;AACpB","debugId":null}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/untitled%20folder/src/models/orderModel.js"],"sourcesContent":["// models/orderModel.js\nimport mongoose from \"mongoose\";\n\nconst { Schema } = mongoose;\n\n/**\n * Minimal snapshot item schema used inside Order documents.\n * We intentionally store product name and unitPrice as snapshot values\n * to preserve historical pricing even if product changes later.\n */\nconst orderItemSchema = new Schema({\n  productId: { type: Schema.Types.ObjectId, ref: \"Product\", required: true },\n  name: { type: String, required: true },\n  sizeLabel: { type: String, required: true },\n  qty: { type: Number, required: true, min: 1 },\n  unitPrice: { type: Number, required: true },\n  subtotal: { type: Number, required: true },\n}, { _id: false });\n\nconst orderSchema = new Schema({\n  customer: {\n    name: { type: String, required: true },\n    email: { type: String },\n    phone: { type: String },\n    address: { type: String },\n  },\n  items: { type: [orderItemSchema], required: true },\n\n  subtotal: { type: Number, required: true },\n  shipping: { type: Number, default: 0 },\n  tax: { type: Number, default: 0 },\n  discount: { type: Number, default: 0 },\n  total: { type: Number, required: true },\n\n  status: {\n    type: String,\n    enum: [\"created\",\"pending\",\"paid\",\"processing\",\"shipped\",\"delivered\",\"cancelled\",\"refunded\"],\n    default: \"created\"\n  },\n\n  payment: {\n    provider: { type: String },\n    paymentId: { type: String },\n    method: { type: String },\n    paidAt: { type: Date }\n  },\n\n  fulfillment: {\n    trackingNumber: String,\n    carrier: String,\n    shippedAt: Date,\n    deliveredAt: Date\n  },\n\n  userId: { type: Schema.Types.ObjectId, ref: \"User\" },\n  meta: { type: Schema.Types.Mixed },\n  archived: { type: Boolean, default: false }\n}, { timestamps: true });\n\n// Useful indexes for listing and filtering orders\norderSchema.index({ userId: 1, createdAt: -1 });\norderSchema.index({ \"customer.email\": 1 });\norderSchema.index({ status: 1, createdAt: -1 });\n\nexport default mongoose.models.Order || mongoose.model(\"Order\", orderSchema);\n"],"names":[],"mappings":"AAAA,uBAAuB;;;;;AACvB;;AAEA,MAAM,EAAE,MAAM,EAAE,GAAG,oHAAQ;AAE3B;;;;CAIC,GACD,MAAM,kBAAkB,IAAI,OAAO;IACjC,WAAW;QAAE,MAAM,OAAO,KAAK,CAAC,QAAQ;QAAE,KAAK;QAAW,UAAU;IAAK;IACzE,MAAM;QAAE,MAAM;QAAQ,UAAU;IAAK;IACrC,WAAW;QAAE,MAAM;QAAQ,UAAU;IAAK;IAC1C,KAAK;QAAE,MAAM;QAAQ,UAAU;QAAM,KAAK;IAAE;IAC5C,WAAW;QAAE,MAAM;QAAQ,UAAU;IAAK;IAC1C,UAAU;QAAE,MAAM;QAAQ,UAAU;IAAK;AAC3C,GAAG;IAAE,KAAK;AAAM;AAEhB,MAAM,cAAc,IAAI,OAAO;IAC7B,UAAU;QACR,MAAM;YAAE,MAAM;YAAQ,UAAU;QAAK;QACrC,OAAO;YAAE,MAAM;QAAO;QACtB,OAAO;YAAE,MAAM;QAAO;QACtB,SAAS;YAAE,MAAM;QAAO;IAC1B;IACA,OAAO;QAAE,MAAM;YAAC;SAAgB;QAAE,UAAU;IAAK;IAEjD,UAAU;QAAE,MAAM;QAAQ,UAAU;IAAK;IACzC,UAAU;QAAE,MAAM;QAAQ,SAAS;IAAE;IACrC,KAAK;QAAE,MAAM;QAAQ,SAAS;IAAE;IAChC,UAAU;QAAE,MAAM;QAAQ,SAAS;IAAE;IACrC,OAAO;QAAE,MAAM;QAAQ,UAAU;IAAK;IAEtC,QAAQ;QACN,MAAM;QACN,MAAM;YAAC;YAAU;YAAU;YAAO;YAAa;YAAU;YAAY;YAAY;SAAW;QAC5F,SAAS;IACX;IAEA,SAAS;QACP,UAAU;YAAE,MAAM;QAAO;QACzB,WAAW;YAAE,MAAM;QAAO;QAC1B,QAAQ;YAAE,MAAM;QAAO;QACvB,QAAQ;YAAE,MAAM;QAAK;IACvB;IAEA,aAAa;QACX,gBAAgB;QAChB,SAAS;QACT,WAAW;QACX,aAAa;IACf;IAEA,QAAQ;QAAE,MAAM,OAAO,KAAK,CAAC,QAAQ;QAAE,KAAK;IAAO;IACnD,MAAM;QAAE,MAAM,OAAO,KAAK,CAAC,KAAK;IAAC;IACjC,UAAU;QAAE,MAAM;QAAS,SAAS;IAAM;AAC5C,GAAG;IAAE,YAAY;AAAK;AAEtB,kDAAkD;AAClD,YAAY,KAAK,CAAC;IAAE,QAAQ;IAAG,WAAW,CAAC;AAAE;AAC7C,YAAY,KAAK,CAAC;IAAE,kBAAkB;AAAE;AACxC,YAAY,KAAK,CAAC;IAAE,QAAQ;IAAG,WAAW,CAAC;AAAE;uCAE9B,oHAAQ,CAAC,MAAM,CAAC,KAAK,IAAI,oHAAQ,CAAC,KAAK,CAAC,SAAS","debugId":null}},
    {"offset": {"line": 204, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/untitled%20folder/src/models/productModel.js"],"sourcesContent":["// models/productModel.js\nimport mongoose from \"mongoose\";\n\nconst sizeSchema = new mongoose.Schema({\n  label: { type: String, required: true },\n  // added min: 0 to prevent negative stock values when validators run\n  stock: { type: Number, default: 0, min: 0 },\n}, { _id: false });\n\nconst ratingSchema = new mongoose.Schema({\n  avg: { type: Number, default: 0 },\n  count: { type: Number, default: 0 },\n}, { _id: false });\n\n/**\n * Product schema - stores snapshot of product data and size-level stock.\n * Use integer currency values (e.g., rupees or paisa) consistently across the app.\n */\nconst productSchema = new mongoose.Schema({\n  name: { type: String, required: true },\n  price: { type: Number, required: true },\n  originalPrice: { type: Number, default: 0 },\n  description: { type: String, default: \"\" },\n  materials: { type: [String], default: [] },\n  images: { type: [String], default: [] },\n  sizes: { type: [sizeSchema], default: [] },\n  rating: { type: ratingSchema, default: () => ({}) },\n  category: { type: String, default: \"General\" }\n}, { timestamps: true });\n\n// Text index for full-text search on name and description\nproductSchema.index({ name: \"text\", description: \"text\" });\n\n// Prevent model overwrite in dev/hot-reload environments (Next.js etc.)\nconst Product = mongoose.models.Product || mongoose.model(\"Product\", productSchema);\n\nexport default Product;\n"],"names":[],"mappings":"AAAA,yBAAyB;;;;;AACzB;;AAEA,MAAM,aAAa,IAAI,oHAAQ,CAAC,MAAM,CAAC;IACrC,OAAO;QAAE,MAAM;QAAQ,UAAU;IAAK;IACtC,oEAAoE;IACpE,OAAO;QAAE,MAAM;QAAQ,SAAS;QAAG,KAAK;IAAE;AAC5C,GAAG;IAAE,KAAK;AAAM;AAEhB,MAAM,eAAe,IAAI,oHAAQ,CAAC,MAAM,CAAC;IACvC,KAAK;QAAE,MAAM;QAAQ,SAAS;IAAE;IAChC,OAAO;QAAE,MAAM;QAAQ,SAAS;IAAE;AACpC,GAAG;IAAE,KAAK;AAAM;AAEhB;;;CAGC,GACD,MAAM,gBAAgB,IAAI,oHAAQ,CAAC,MAAM,CAAC;IACxC,MAAM;QAAE,MAAM;QAAQ,UAAU;IAAK;IACrC,OAAO;QAAE,MAAM;QAAQ,UAAU;IAAK;IACtC,eAAe;QAAE,MAAM;QAAQ,SAAS;IAAE;IAC1C,aAAa;QAAE,MAAM;QAAQ,SAAS;IAAG;IACzC,WAAW;QAAE,MAAM;YAAC;SAAO;QAAE,SAAS,EAAE;IAAC;IACzC,QAAQ;QAAE,MAAM;YAAC;SAAO;QAAE,SAAS,EAAE;IAAC;IACtC,OAAO;QAAE,MAAM;YAAC;SAAW;QAAE,SAAS,EAAE;IAAC;IACzC,QAAQ;QAAE,MAAM;QAAc,SAAS,IAAM,CAAC,CAAC,CAAC;IAAE;IAClD,UAAU;QAAE,MAAM;QAAQ,SAAS;IAAU;AAC/C,GAAG;IAAE,YAAY;AAAK;AAEtB,0DAA0D;AAC1D,cAAc,KAAK,CAAC;IAAE,MAAM;IAAQ,aAAa;AAAO;AAExD,wEAAwE;AACxE,MAAM,UAAU,oHAAQ,CAAC,MAAM,CAAC,OAAO,IAAI,oHAAQ,CAAC,KAAK,CAAC,WAAW;uCAEtD","debugId":null}},
    {"offset": {"line": 298, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/untitled%20folder/src/services/inventory.js"],"sourcesContent":["// src/services/inventory.js\nimport Product from \"models/productModel.js\";\n\n/**\n * @file InventoryService\n * @brief Centralized product stock operations (sizes array).\n *\n * Responsibilities:\n *  - Single-item atomic updates (increaseStock, decreaseStock)\n *  - Multi-item transactional decrement (decreaseStockForItems)\n *  - Safe helpers for adding sizes, checking stock, and total stock\n *\n * Notes:\n *  - We use runValidators: true on updateOne to enforce schema constraints\n *    such as min: 0 on size.stock.\n *  - After each decrement we read back the value and throw if stock is negative\n *    so callers (inside transactions) can abort and avoid persisted negative values.\n */\n\n/** Base error for inventory operations */\nclass InventoryError extends Error {}\n/** Thrown when requested qty cannot be satisfied */\nclass InsufficientStockError extends InventoryError {}\n/** Thrown when input params are invalid */\nclass InvalidParamsError extends InventoryError {}\n\nexport default class InventoryService {\n  /**\n   * Normalize size label defensively.\n   * @private\n   * @param {any} sizeLabel\n   * @returns {string}\n   */\n  static _normalizeLabel(sizeLabel) {\n    return sizeLabel === undefined || sizeLabel === null ? \"\" : String(sizeLabel).trim();\n  }\n\n  /**\n   * Validate and normalize params for single-item operations.\n   * Throws InvalidParamsError on invalid input.\n   * @private\n   * @param {String|ObjectId} productId\n   * @param {String} sizeLabel\n   * @param {Number} qty\n   * @returns {{productId:*, sizeLabel:string, qty:number}}\n   */\n  static _validateParams(productId, sizeLabel, qty) {\n    if (!productId) throw new InvalidParamsError(\"productId is required\");\n    const label = this._normalizeLabel(sizeLabel);\n    if (!label) throw new InvalidParamsError(\"sizeLabel is required\");\n    const q = Number(qty);\n    if (!Number.isFinite(q) || q <= 0) throw new InvalidParamsError(\"qty must be a positive number\");\n    return { productId, sizeLabel: label, qty: Math.floor(q) };\n  }\n\n  /**\n   * Decrease stock for a specific product size by qty.\n   * If a mongoose session is provided, the update participates in the transaction.\n   * Uses runValidators to ensure schema constraints (min:0) are enforced.\n   * @param {String|ObjectId} productId\n   * @param {String} sizeLabel\n   * @param {Number} qty\n   * @param {mongoose.ClientSession} [session]\n   * @returns {Promise<boolean>} true if modified, throws InsufficientStockError otherwise\n   * @throws {InvalidParamsError|InsufficientStockError}\n   */\n  static async decreaseStock(productId, sizeLabel, qty, session = null) {\n    const params = this._validateParams(productId, sizeLabel, qty);\n\n    const filter = {\n      _id: params.productId,\n      \"sizes.label\": params.sizeLabel,\n      \"sizes.stock\": { $gte: params.qty }\n    };\n\n    const update = { $inc: { \"sizes.$[el].stock\": -params.qty } };\n    // include runValidators to enforce schema min:0\n    const options = { arrayFilters: [{ \"el.label\": params.sizeLabel }], runValidators: true };\n    if (session) options.session = session;\n\n    const res = await Product.updateOne(filter, update, options);\n    const modified = (res.modifiedCount ?? res.nModified ?? 0) > 0;\n\n    if (!modified) {\n      // fetch current available stock for better error message\n      const current = await Product.findOne(\n        { _id: params.productId, \"sizes.label\": params.sizeLabel },\n        { \"sizes.$\": 1 }\n      ).session(session).lean();\n\n      const available = current && current.sizes && current.sizes[0] ? Number(current.sizes[0].stock || 0) : 0;\n      throw new InsufficientStockError(`Insufficient stock for product ${params.productId} size ${params.sizeLabel}. Requested ${params.qty}, available ${available}`);\n    }\n\n    // defensive post-check: ensure new stock is not negative\n    const post = await Product.findOne(\n      { _id: params.productId, \"sizes.label\": params.sizeLabel },\n      { \"sizes.$\": 1 }\n    ).session(session).lean();\n\n    const newStock = post && post.sizes && post.sizes[0] ? Number(post.sizes[0].stock || 0) : 0;\n    if (newStock < 0) {\n      throw new InsufficientStockError(`Post-update stock negative (${newStock}) for product ${params.productId} size ${params.sizeLabel}`);\n    }\n\n    return true;\n  }\n\n  /**\n   * Increase stock for a specific product size by qty (restock/cancel).\n   * Returns true if an existing size was updated, false if not found (size missing).\n   * Use addOrCreateSize to add a missing size.\n   * @param {String|ObjectId} productId\n   * @param {String} sizeLabel\n   * @param {Number} qty\n   * @param {mongoose.ClientSession} [session]\n   * @returns {Promise<boolean>}\n   */\n  static async increaseStock(productId, sizeLabel, qty, session = null) {\n    const params = this._validateParams(productId, sizeLabel, qty);\n\n    const filter = { _id: params.productId, \"sizes.label\": params.sizeLabel };\n    const update = { $inc: { \"sizes.$[el].stock\": params.qty } };\n    const options = { arrayFilters: [{ \"el.label\": params.sizeLabel }], runValidators: true };\n    if (session) options.session = session;\n\n    const res = await Product.updateOne(filter, update, options);\n    const modified = (res.modifiedCount ?? res.nModified ?? 0) > 0;\n\n    if (modified) {\n      // post-check to ensure validators didn't allow a bad state\n      const post = await Product.findOne(\n        { _id: params.productId, \"sizes.label\": params.sizeLabel },\n        { \"sizes.$\": 1 }\n      ).session(session).lean();\n      const newStock = post && post.sizes && post.sizes[0] ? Number(post.sizes[0].stock || 0) : 0;\n      if (newStock < 0) {\n        throw new InventoryError(`Post-increase stock negative (${newStock}) for product ${params.productId} size ${params.sizeLabel}`);\n      }\n      return true;\n    }\n\n    // size missing -> return false to let callers add/create\n    return false;\n  }\n\n  /**\n   * Add a new size entry if it doesn't exist, or set the stock if it does.\n   * @param {String|ObjectId} productId\n   * @param {String} sizeLabel\n   * @param {Number} qty\n   * @param {mongoose.ClientSession} [session]\n   * @returns {Promise<void>}\n   * @throws {InvalidParamsError}\n   */\n  static async addOrCreateSize(productId, sizeLabel, qty = 0, session = null) {\n    if (!productId) throw new InvalidParamsError(\"productId is required\");\n    const label = this._normalizeLabel(sizeLabel);\n    if (!label) throw new InvalidParamsError(\"sizeLabel is required\");\n    const q = Math.max(0, Math.floor(Number(qty) || 0));\n    const options = { arrayFilters: [{ \"el.label\": label }], runValidators: true };\n    if (session) options.session = session;\n\n    // Try update first; if not matched, push a new size\n    const res = await Product.updateOne(\n      { _id: productId, \"sizes.label\": label },\n      { $set: { \"sizes.$[el].stock\": q } },\n      options\n    );\n\n    if ((res.modifiedCount ?? res.nModified ?? 0) === 0) {\n      await Product.updateOne(\n        { _id: productId },\n        { $push: { sizes: { label, stock: q } } },\n        session ? { session } : {}\n      );\n    }\n  }\n\n  /**\n   * Get stock for a specific size. Returns 0 if product or size not found.\n   * @param {String|ObjectId} productId\n   * @param {String} sizeLabel\n   * @returns {Promise<number>}\n   */\n  static async getStock(productId, sizeLabel) {\n    if (!productId) throw new InvalidParamsError(\"productId is required\");\n    const label = this._normalizeLabel(sizeLabel);\n    if (!label) throw new InvalidParamsError(\"sizeLabel is required\");\n\n    const doc = await Product.findById(productId, { sizes: 1 }).lean();\n    if (!doc || !Array.isArray(doc.sizes)) return 0;\n    const s = doc.sizes.find(x => String(x.label).trim() === label);\n    return s ? Number(s.stock || 0) : 0;\n  }\n\n  /**\n   * Returns total stock across all sizes for the product (integer).\n   * @param {String|ObjectId} productId\n   * @returns {Promise<number>}\n   */\n  static async totalStock(productId) {\n    if (!productId) throw new InvalidParamsError(\"productId is required\");\n    const doc = await Product.findById(productId, { sizes: 1 }).lean();\n    if (!doc || !Array.isArray(doc.sizes)) return 0;\n    return doc.sizes.reduce((sum, s) => sum + Math.max(0, Number(s.stock || 0)), 0);\n  }\n\n  /**\n   * Decrease stock for multiple items inside a session/transaction.\n   * This method expects a mongoose session that has had startTransaction called.\n   * It will throw InsufficientStockError if any individual decrement cannot be applied.\n   *\n   * @param {Array<{productId: string, sizeLabel: string, qty: number}>} items\n   * @param {mongoose.ClientSession} session - required\n   * @returns {Promise<void>}\n   * @throws {InvalidParamsError|InsufficientStockError}\n   */\n  static async decreaseStockForItems(items = [], session) {\n    if (!Array.isArray(items) || items.length === 0) return;\n    if (!session) throw new InvalidParamsError(\"A mongoose session is required for multi-item decrease\");\n\n    // Validate items and normalize labels\n    for (const it of items) {\n      it.sizeLabel = this._normalizeLabel(it.sizeLabel);\n      this._validateParams(it.productId, it.sizeLabel, it.qty);\n    }\n\n    // Attempt each update; on failure fetch available and throw InsufficientStockError\n    for (const it of items) {\n      const updated = await Product.updateOne(\n        {\n          _id: it.productId,\n          \"sizes.label\": it.sizeLabel,\n          \"sizes.stock\": { $gte: it.qty }\n        },\n        { $inc: { \"sizes.$[el].stock\": -it.qty } },\n        { arrayFilters: [{ \"el.label\": it.sizeLabel }], session, runValidators: true }\n      );\n\n      const modified = (updated.modifiedCount ?? updated.nModified ?? 0) > 0;\n      if (!modified) {\n        const current = await Product.findOne(\n          { _id: it.productId, \"sizes.label\": it.sizeLabel },\n          { \"sizes.$\": 1 }\n        ).session(session).lean();\n\n        const available = current && current.sizes && current.sizes[0] ? Number(current.sizes[0].stock || 0) : 0;\n        throw new InsufficientStockError(\n          `Insufficient stock for product ${it.productId} size ${it.sizeLabel}. Requested ${it.qty}, available ${available}`\n        );\n      }\n\n      // post-check\n      const post = await Product.findOne(\n        { _id: it.productId, \"sizes.label\": it.sizeLabel },\n        { \"sizes.$\": 1 }\n      ).session(session).lean();\n\n      const newStock = post && post.sizes && post.sizes[0] ? Number(post.sizes[0].stock || 0) : 0;\n      if (newStock < 0) {\n        throw new InsufficientStockError(\n          `Post-update stock negative (${newStock}) for product ${it.productId} size ${it.sizeLabel}`\n        );\n      }\n    }\n    // all decrements succeeded (still inside caller's transaction)\n  }\n}\n\n// Export error classes for callers that want to check error types.\nexport { InventoryError, InsufficientStockError, InvalidParamsError };\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 611, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/untitled%20folder/src/domain/orders.js"],"sourcesContent":["// src/domain/orders.js\n\n/**\n * @file DomainOrder\n * @brief DB-agnostic Domain class representing an Order with lifecycle helpers.\n *\n * Extends the original DomainOrder with status transition helpers (markAsShipped, markAsCancelled, markAsRefunded, etc.)\n * These methods modify the in-memory domain object; persistence should be done by service layers.\n */\n\nfunction toNumberSafe(value, fallback = 0) {\n  if (value === undefined || value === null) return fallback;\n  if (typeof value === \"number\" && Number.isFinite(value)) return value;\n  const n = Number(value);\n  return Number.isFinite(n) ? n : fallback;\n}\n\nfunction toDateSafe(value) {\n  if (!value) return undefined;\n  const d = value instanceof Date ? value : new Date(value);\n  return Number.isNaN(d.getTime()) ? undefined : d;\n}\n\n/**\n * @typedef OrderItem\n * @property {string|any} productId - product ObjectId or string\n * @property {string} name - product name (snapshot)\n * @property {string} sizeLabel\n * @property {number} qty\n * @property {number} unitPrice - integer currency\n * @property {number} subtotal - unitPrice * qty\n */\n\n/**\n * @class DomainOrder\n * @brief Domain representation of an order with helpers & validation.\n */\nexport class DomainOrder {\n  /**\n   * Valid order statuses (mirrors orderModel.js enum).\n   * @returns {string[]}\n   */\n  static get VALID_STATUSES() {\n    return [\"created\",\"pending\",\"paid\",\"processing\",\"shipped\",\"delivered\",\"cancelled\",\"refunded\"];\n  }\n\n  /**\n   * Allowed transitions map (current -> [allowed next statuses])\n   * This is conservative but covers common flows. Services can override/allow others.\n   * @returns {Object}\n   */\n  static get TRANSITIONS() {\n    return {\n      created: [\"pending\", \"paid\", \"processing\", \"cancelled\"],\n      pending: [\"paid\", \"processing\", \"cancelled\"],\n      paid: [\"processing\", \"cancelled\", \"refunded\"],\n      processing: [\"shipped\", \"cancelled\", \"refunded\"],\n      shipped: [\"delivered\", \"refunded\"],\n      delivered: [], // final\n      cancelled: [], // final\n      refunded: [] // final\n    };\n  }\n\n  /**\n   * @param {Object} params\n   * @param {Object} params.customer - { name, email?, phone?, address? }\n   * @param {OrderItem[]} [params.items=[]]\n   * @param {number} [params.subtotal=0]\n   * @param {number} [params.shipping=0]\n   * @param {number} [params.tax=0]\n   * @param {number} [params.discount=0]\n   * @param {number} [params.total=0]\n   * @param {string} [params.status=\"created\"]\n   * @param {string|Date} [params.createdAt]\n   * @param {string|Date} [params.updatedAt]\n   * @param {string|any} [params._id]\n   */\n  constructor({\n    _id = undefined,\n    customer = {},\n    items = [],\n    subtotal = 0,\n    shipping = 0,\n    tax = 0,\n    discount = 0,\n    total = 0,\n    status = \"created\",\n    createdAt = undefined,\n    updatedAt = undefined,\n    userId = undefined,\n    meta = undefined,\n    archived = false,\n    payment = undefined,\n    fulfillment = undefined\n  } = {}) {\n    // Basic validation\n    if (!customer || !String(customer.name || \"\").trim()) {\n      throw new Error(\"customer.name is required\");\n    }\n\n    if (!Array.isArray(items) || items.length === 0) {\n      // allow creation of an order object with empty items only if explicitly desired,\n      // but by default require at least one item for a valid order.\n      throw new Error(\"Order must contain at least one item\");\n    }\n\n    // Normalize items\n    this.items = items.map(it => DomainOrder._normalizeItem(it));\n\n    // Validate items (throws if invalid)\n    for (const it of this.items) {\n      DomainOrder._validateItem(it);\n    }\n\n    this._id = _id;\n    this.customer = {\n      name: String(customer.name),\n      email: customer.email ? String(customer.email) : undefined,\n      phone: customer.phone ? String(customer.phone) : undefined,\n      address: customer.address ? String(customer.address) : undefined,\n    };\n\n    this.subtotal = toNumberSafe(subtotal, 0);\n    this.shipping = toNumberSafe(shipping, 0);\n    this.tax = toNumberSafe(tax, 0);\n    this.discount = toNumberSafe(discount, 0);\n    this.total = toNumberSafe(total, 0);\n\n    // Ensure status is valid\n    this.status = DomainOrder.VALID_STATUSES.includes(String(status)) ? String(status) : \"created\";\n\n    this.createdAt = toDateSafe(createdAt);\n    this.updatedAt = toDateSafe(updatedAt);\n    this.userId = userId;\n    this.meta = meta || {};\n    this.archived = Boolean(archived);\n\n    // Optional nested objects\n    this.payment = payment || {};\n    this.fulfillment = fulfillment || {};\n  }\n\n  /**\n   * Normalize an incoming item to the expected shape.\n   * Does not fully validate (see _validateItem).\n   * @private\n   * @param {Object} it\n   * @returns {OrderItem}\n   */\n  static _normalizeItem(it = {}) {\n    return {\n      productId: it.productId,\n      name: it.name ? String(it.name) : \"\",\n      sizeLabel: it.sizeLabel ? String(it.sizeLabel) : \"\",\n      qty: Math.max(0, Math.floor(toNumberSafe(it.qty, 0))),\n      unitPrice: toNumberSafe(it.unitPrice, 0),\n      subtotal: toNumberSafe(it.subtotal, 0),\n    };\n  }\n\n  /**\n   * Validate a normalized item and ensure subtotal is consistent.\n   * Throws Error on invalid item.\n   * @private\n   * @param {OrderItem} it\n   */\n  static _validateItem(it) {\n    if (!it.productId) throw new Error(\"item.productId is required\");\n    if (!it.name || String(it.name).trim() === \"\") throw new Error(\"item.name is required\");\n    if (!it.sizeLabel || String(it.sizeLabel).trim() === \"\") throw new Error(\"item.sizeLabel is required\");\n    if (!Number.isFinite(it.qty) || it.qty <= 0) throw new Error(\"item.qty must be a positive integer\");\n    if (!Number.isFinite(it.unitPrice) || it.unitPrice < 0) throw new Error(\"item.unitPrice must be a number >= 0\");\n\n    const expected = Math.floor(it.unitPrice * it.qty);\n    // Ensure subtotal consistent; if not provided, set it.\n    if (!Number.isFinite(it.subtotal) || it.subtotal !== expected) {\n      it.subtotal = expected;\n    }\n  }\n\n  /**\n   * Create a DomainOrder from a Mongoose document or plain object.\n   * @param {Object} doc\n   * @returns {DomainOrder}\n   */\n  static fromDocument(doc = {}) {\n    const d = doc && typeof doc.toObject === \"function\" ? doc.toObject() : doc || {};\n    return new DomainOrder({\n      _id: d._id,\n      customer: d.customer || {},\n      items: (d.items || []).map(i => ({\n        productId: i.productId,\n        name: i.name,\n        sizeLabel: i.sizeLabel,\n        qty: toNumberSafe(i.qty, 0),\n        unitPrice: toNumberSafe(i.unitPrice, 0),\n        subtotal: toNumberSafe(i.subtotal, 0),\n      })),\n      subtotal: toNumberSafe(d.subtotal, 0),\n      shipping: toNumberSafe(d.shipping, 0),\n      tax: toNumberSafe(d.tax, 0),\n      discount: toNumberSafe(d.discount, 0),\n      total: toNumberSafe(d.total, 0),\n      status: d.status || \"created\",\n      createdAt: d.createdAt,\n      updatedAt: d.updatedAt,\n      userId: d.userId,\n      meta: d.meta,\n      archived: d.archived || false,\n      payment: d.payment,\n      fulfillment: d.fulfillment\n    });\n  }\n\n  /**\n   * Validate a plain payload before constructing or saving.\n   * Throws Error on invalid payload. Returns true on success.\n   * @param {Object} payload\n   * @returns {boolean}\n   */\n  static validate(payload = {}) {\n    if (!payload) throw new Error(\"Payload is required\");\n    if (!payload.customer || !String(payload.customer.name || \"\").trim()) throw new Error(\"customer.name is required\");\n    if (!Array.isArray(payload.items) || payload.items.length === 0) throw new Error(\"items must be a non-empty array\");\n\n    for (const it of payload.items) {\n      const n = DomainOrder._normalizeItem(it);\n      DomainOrder._validateItem(n);\n    }\n    return true;\n  }\n\n  /**\n   * Recalculate subtotal and total based on items and adjustments.\n   * Sets this.subtotal and this.total.\n   * @param {Object} [opts]\n   * @param {boolean} [opts.recalculateItemSubtotals=true] - recalc each item.subtotal from unitPrice * qty\n   */\n  calculateTotals({ recalculateItemSubtotals = true } = {}) {\n    if (!Array.isArray(this.items)) this.items = [];\n    let subtotal = 0;\n    for (const it of this.items) {\n      if (recalculateItemSubtotals) {\n        it.subtotal = Math.floor(toNumberSafe(it.unitPrice, 0) * toNumberSafe(it.qty, 0));\n      }\n      subtotal += toNumberSafe(it.subtotal, 0);\n    }\n    this.subtotal = Math.floor(subtotal);\n    // basic total calculation; consumers can set shipping/tax/discount before/after calling this\n    this.total = Math.max(0, this.subtotal + toNumberSafe(this.shipping, 0) + toNumberSafe(this.tax, 0) - toNumberSafe(this.discount, 0));\n    return { subtotal: this.subtotal, total: this.total };\n  }\n\n  /**\n   * Add an item to the order (merges with existing item with same productId+sizeLabel).\n   * Recalculates totals.\n   * @param {OrderItem} item\n   */\n  addItem(item = {}) {\n    const it = DomainOrder._normalizeItem(item);\n    DomainOrder._validateItem(it);\n\n    const idx = this.items.findIndex(x => String(x.productId) === String(it.productId) && String(x.sizeLabel) === String(it.sizeLabel));\n    if (idx === -1) {\n      this.items.push(it);\n    } else {\n      // merge qty and recompute subtotal\n      this.items[idx].qty = Math.floor(toNumberSafe(this.items[idx].qty, 0) + it.qty);\n      this.items[idx].unitPrice = toNumberSafe(it.unitPrice, this.items[idx].unitPrice);\n      this.items[idx].subtotal = Math.floor(this.items[idx].unitPrice * this.items[idx].qty);\n    }\n    this.calculateTotals();\n  }\n\n  /**\n   * Remove an item by productId and sizeLabel.\n   * @param {string|any} productId\n   * @param {string} sizeLabel\n   * @returns {boolean} true if removed\n   */\n  removeItem(productId, sizeLabel) {\n    const prevLen = this.items.length;\n    this.items = this.items.filter(x => !(String(x.productId) === String(productId) && String(x.sizeLabel) === String(sizeLabel)));\n    const removed = this.items.length < prevLen;\n    if (removed) this.calculateTotals();\n    return removed;\n  }\n\n  /**\n   * Update quantity for an existing item.\n   * @param {string|any} productId\n   * @param {string} sizeLabel\n   * @param {number} qty\n   * @returns {boolean} true if updated\n   */\n  updateItemQty(productId, sizeLabel, qty) {\n    const idx = this.items.findIndex(x => String(x.productId) === String(productId) && String(x.sizeLabel) === String(sizeLabel));\n    if (idx === -1) return false;\n    const q = Math.floor(toNumberSafe(qty, 0));\n    if (q <= 0) return false;\n    this.items[idx].qty = q;\n    this.items[idx].subtotal = Math.floor(this.items[idx].unitPrice * q);\n    this.calculateTotals();\n    return true;\n  }\n\n  /**\n   * Determine if a transition from current status to newStatus is allowed.\n   * @param {string} newStatus\n   * @returns {boolean}\n   */\n  canTransitionTo(newStatus) {\n    if (!newStatus) return false;\n    const cur = String(this.status || \"\").trim();\n    if (!DomainOrder.VALID_STATUSES.includes(newStatus)) return false;\n    const allowed = DomainOrder.TRANSITIONS[cur] || [];\n    return allowed.includes(newStatus);\n  }\n\n  /**\n   * Returns true if the order is in a final/terminal status.\n   * @returns {boolean}\n   */\n  isFinal() {\n    return [\"delivered\", \"cancelled\", \"refunded\"].includes(this.status);\n  }\n\n  /**\n   * Ensure fulfillment object exists.\n   * @private\n   */\n  ensureFulfillment() {\n    if (!this.fulfillment || typeof this.fulfillment !== \"object\") this.fulfillment = {};\n  }\n\n  /**\n   * Ensure payment object exists.\n   * @private\n   */\n  ensurePayment() {\n    if (!this.payment || typeof this.payment !== \"object\") this.payment = {};\n  }\n\n  /**\n   * Mark order as processing if allowed.\n   * @returns {boolean} true if applied\n   */\n  markAsProcessing() {\n    if (!this.canTransitionTo(\"processing\")) return false;\n    this.status = \"processing\";\n    this.updatedAt = new Date();\n    return true;\n  }\n\n  /**\n   * Mark order as shipped. Accepts optional fulfillment data.\n   * Does not persist — caller must save.\n   *\n   * @param {Object} opts\n   * @param {string} [opts.carrier]\n   * @param {string} [opts.trackingNumber]\n   * @param {string|Date} [opts.shippedAt]\n   * @returns {boolean} true if applied\n   */\n  markAsShipped({ carrier, trackingNumber, shippedAt } = {}) {\n    if (!this.canTransitionTo(\"shipped\")) return false;\n    this.status = \"shipped\";\n    this.ensureFulfillment();\n    if (carrier !== undefined) this.fulfillment.carrier = String(carrier);\n    if (trackingNumber !== undefined) this.fulfillment.trackingNumber = String(trackingNumber);\n    this.fulfillment.shippedAt = toDateSafe(shippedAt) || new Date();\n    this.updatedAt = new Date();\n    return true;\n  }\n\n  /**\n   * Mark order as delivered. Optionally set deliveredAt.\n   * @param {Object} opts\n   * @param {string|Date} [opts.deliveredAt]\n   * @returns {boolean}\n   */\n  markAsDelivered({ deliveredAt } = {}) {\n    if (!this.canTransitionTo(\"delivered\")) return false;\n    this.status = \"delivered\";\n    this.ensureFulfillment();\n    this.fulfillment.deliveredAt = toDateSafe(deliveredAt) || new Date();\n    this.updatedAt = new Date();\n    return true;\n  }\n\n  /**\n   * Mark order as cancelled. Records cancel reason in meta.\n   * Note: Domain doesn't automatically restore stock or refund — services should orchestrate those.\n   * @param {Object} opts\n   * @param {string} [opts.reason]\n   * @returns {boolean}\n   */\n  markAsCancelled({ reason } = {}) {\n    if (!this.canTransitionTo(\"cancelled\")) return false;\n    this.status = \"cancelled\";\n    this.meta = this.meta || {};\n    this.meta.cancel = Object.assign({}, this.meta.cancel || {}, {\n      at: new Date(),\n      reason: reason ? String(reason) : undefined\n    });\n    this.updatedAt = new Date();\n    return true;\n  }\n\n  /**\n   * Mark order as refunded and attach refund metadata to payment and meta.\n   * Services should call payment-provider refund before or alongside this.\n   * @param {Object} opts\n   * @param {Object} [opts.refundInfo] - provider refund metadata\n   * @returns {boolean}\n   */\n  markAsRefunded({ refundInfo = {} } = {}) {\n    if (!this.canTransitionTo(\"refunded\")) return false;\n    this.status = \"refunded\";\n    this.ensurePayment();\n    this.payment.refundInfo = Object.assign({}, this.payment.refundInfo || {}, refundInfo);\n    this.payment.refundedAt = this.payment.refundedAt || new Date();\n    this.meta = this.meta || {};\n    this.meta.refund = { at: new Date(), info: refundInfo };\n    this.updatedAt = new Date();\n    return true;\n  }\n\n  /**\n   * Set or update tracking number.\n   * @param {string} trackingNumber\n   */\n  setTrackingNumber(trackingNumber) {\n    if (!trackingNumber) return;\n    this.ensureFulfillment();\n    this.fulfillment.trackingNumber = String(trackingNumber);\n    this.updatedAt = new Date();\n  }\n\n  /**\n   * Add arbitrary meta at top-level or nested path (simple dot path supported).\n   * Example: addMeta('customerNotes', 'left at door') or addMeta('shipping.attempts', 1)\n   *\n   * @param {string} pathOrKey\n   * @param {*} value\n   */\n  addMeta(pathOrKey, value) {\n    if (!pathOrKey) return;\n    const parts = String(pathOrKey).split(\".\").map(p => p.trim()).filter(Boolean);\n    if (parts.length === 0) return;\n    this.meta = this.meta || {};\n    let cur = this.meta;\n    for (let i = 0; i < parts.length - 1; i++) {\n      const k = parts[i];\n      if (!cur[k] || typeof cur[k] !== \"object\") cur[k] = {};\n      cur = cur[k];\n    }\n    cur[parts[parts.length - 1]] = value;\n    this.updatedAt = new Date();\n  }\n\n  /**\n   * Convert the domain object into a plain object suitable for Mongoose saving.\n   * @param {Object} [opts]\n   * @param {boolean} [opts.omitId=false]\n   * @returns {Object}\n   */\n  toObject({ omitId = false } = {}) {\n    const obj = {\n      customer: {\n        name: this.customer.name,\n        email: this.customer.email,\n        phone: this.customer.phone,\n        address: this.customer.address,\n      },\n      items: Array.isArray(this.items) ? this.items.map(it => ({\n        productId: it.productId,\n        name: it.name,\n        sizeLabel: it.sizeLabel,\n        qty: Math.floor(toNumberSafe(it.qty, 0)),\n        unitPrice: Math.floor(toNumberSafe(it.unitPrice, 0)),\n        subtotal: Math.floor(toNumberSafe(it.subtotal, 0)),\n      })) : [],\n      subtotal: Math.floor(toNumberSafe(this.subtotal, 0)),\n      shipping: Math.floor(toNumberSafe(this.shipping, 0)),\n      tax: Math.floor(toNumberSafe(this.tax, 0)),\n      discount: Math.floor(toNumberSafe(this.discount, 0)),\n      total: Math.floor(toNumberSafe(this.total, 0)),\n      status: this.status || \"created\",\n      userId: this.userId,\n      meta: this.meta,\n      archived: Boolean(this.archived),\n      payment: this.payment,\n      fulfillment: this.fulfillment\n    };\n\n    if (!omitId && this._id !== undefined) obj._id = this._id;\n    if (this.createdAt) obj.createdAt = this.createdAt;\n    if (this.updatedAt) obj.updatedAt = this.updatedAt;\n    return obj;\n  }\n\n  /**\n   * toJSON for safe serialization (JSON.stringify).\n   * Adds `id` field as string for convenience.\n   * @returns {Object}\n   */\n  toJSON() {\n    const o = this.toObject({ omitId: false });\n    if (o._id !== undefined && (typeof o._id === \"object\" || typeof o._id === \"string\")) {\n      o.id = String(o._id);\n    }\n    return o;\n  }\n\n  /**\n   * Create a deep clone.\n   * @returns {DomainOrder}\n   */\n  clone() {\n    return DomainOrder.fromDocument(JSON.parse(JSON.stringify(this.toObject())));\n  }\n}\n\nexport default DomainOrder;\n"],"names":[],"mappings":"AAAA,uBAAuB;AAEvB;;;;;;CAMC;;;;;;AAED,SAAS,aAAa,KAAK,EAAE,WAAW,CAAC;IACvC,IAAI,UAAU,aAAa,UAAU,MAAM,OAAO;IAClD,IAAI,OAAO,UAAU,YAAY,OAAO,QAAQ,CAAC,QAAQ,OAAO;IAChE,MAAM,IAAI,OAAO;IACjB,OAAO,OAAO,QAAQ,CAAC,KAAK,IAAI;AAClC;AAEA,SAAS,WAAW,KAAK;IACvB,IAAI,CAAC,OAAO,OAAO;IACnB,MAAM,IAAI,iBAAiB,OAAO,QAAQ,IAAI,KAAK;IACnD,OAAO,OAAO,KAAK,CAAC,EAAE,OAAO,MAAM,YAAY;AACjD;AAgBO,MAAM;IACX;;;GAGC,GACD,WAAW,iBAAiB;QAC1B,OAAO;YAAC;YAAU;YAAU;YAAO;YAAa;YAAU;YAAY;YAAY;SAAW;IAC/F;IAEA;;;;GAIC,GACD,WAAW,cAAc;QACvB,OAAO;YACL,SAAS;gBAAC;gBAAW;gBAAQ;gBAAc;aAAY;YACvD,SAAS;gBAAC;gBAAQ;gBAAc;aAAY;YAC5C,MAAM;gBAAC;gBAAc;gBAAa;aAAW;YAC7C,YAAY;gBAAC;gBAAW;gBAAa;aAAW;YAChD,SAAS;gBAAC;gBAAa;aAAW;YAClC,WAAW,EAAE;YACb,WAAW,EAAE;YACb,UAAU,EAAE,CAAC,QAAQ;QACvB;IACF;IAEA;;;;;;;;;;;;;GAaC,GACD,YAAY,EACV,MAAM,SAAS,EACf,WAAW,CAAC,CAAC,EACb,QAAQ,EAAE,EACV,WAAW,CAAC,EACZ,WAAW,CAAC,EACZ,MAAM,CAAC,EACP,WAAW,CAAC,EACZ,QAAQ,CAAC,EACT,SAAS,SAAS,EAClB,YAAY,SAAS,EACrB,YAAY,SAAS,EACrB,SAAS,SAAS,EAClB,OAAO,SAAS,EAChB,WAAW,KAAK,EAChB,UAAU,SAAS,EACnB,cAAc,SAAS,EACxB,GAAG,CAAC,CAAC,CAAE;QACN,mBAAmB;QACnB,IAAI,CAAC,YAAY,CAAC,OAAO,SAAS,IAAI,IAAI,IAAI,IAAI,IAAI;YACpD,MAAM,IAAI,MAAM;QAClB;QAEA,IAAI,CAAC,MAAM,OAAO,CAAC,UAAU,MAAM,MAAM,KAAK,GAAG;YAC/C,iFAAiF;YACjF,8DAA8D;YAC9D,MAAM,IAAI,MAAM;QAClB;QAEA,kBAAkB;QAClB,IAAI,CAAC,KAAK,GAAG,MAAM,GAAG,CAAC,CAAA,KAAM,YAAY,cAAc,CAAC;QAExD,qCAAqC;QACrC,KAAK,MAAM,MAAM,IAAI,CAAC,KAAK,CAAE;YAC3B,YAAY,aAAa,CAAC;QAC5B;QAEA,IAAI,CAAC,GAAG,GAAG;QACX,IAAI,CAAC,QAAQ,GAAG;YACd,MAAM,OAAO,SAAS,IAAI;YAC1B,OAAO,SAAS,KAAK,GAAG,OAAO,SAAS,KAAK,IAAI;YACjD,OAAO,SAAS,KAAK,GAAG,OAAO,SAAS,KAAK,IAAI;YACjD,SAAS,SAAS,OAAO,GAAG,OAAO,SAAS,OAAO,IAAI;QACzD;QAEA,IAAI,CAAC,QAAQ,GAAG,aAAa,UAAU;QACvC,IAAI,CAAC,QAAQ,GAAG,aAAa,UAAU;QACvC,IAAI,CAAC,GAAG,GAAG,aAAa,KAAK;QAC7B,IAAI,CAAC,QAAQ,GAAG,aAAa,UAAU;QACvC,IAAI,CAAC,KAAK,GAAG,aAAa,OAAO;QAEjC,yBAAyB;QACzB,IAAI,CAAC,MAAM,GAAG,YAAY,cAAc,CAAC,QAAQ,CAAC,OAAO,WAAW,OAAO,UAAU;QAErF,IAAI,CAAC,SAAS,GAAG,WAAW;QAC5B,IAAI,CAAC,SAAS,GAAG,WAAW;QAC5B,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,IAAI,GAAG,QAAQ,CAAC;QACrB,IAAI,CAAC,QAAQ,GAAG,QAAQ;QAExB,0BAA0B;QAC1B,IAAI,CAAC,OAAO,GAAG,WAAW,CAAC;QAC3B,IAAI,CAAC,WAAW,GAAG,eAAe,CAAC;IACrC;IAEA;;;;;;GAMC,GACD,OAAO,eAAe,KAAK,CAAC,CAAC,EAAE;QAC7B,OAAO;YACL,WAAW,GAAG,SAAS;YACvB,MAAM,GAAG,IAAI,GAAG,OAAO,GAAG,IAAI,IAAI;YAClC,WAAW,GAAG,SAAS,GAAG,OAAO,GAAG,SAAS,IAAI;YACjD,KAAK,KAAK,GAAG,CAAC,GAAG,KAAK,KAAK,CAAC,aAAa,GAAG,GAAG,EAAE;YACjD,WAAW,aAAa,GAAG,SAAS,EAAE;YACtC,UAAU,aAAa,GAAG,QAAQ,EAAE;QACtC;IACF;IAEA;;;;;GAKC,GACD,OAAO,cAAc,EAAE,EAAE;QACvB,IAAI,CAAC,GAAG,SAAS,EAAE,MAAM,IAAI,MAAM;QACnC,IAAI,CAAC,GAAG,IAAI,IAAI,OAAO,GAAG,IAAI,EAAE,IAAI,OAAO,IAAI,MAAM,IAAI,MAAM;QAC/D,IAAI,CAAC,GAAG,SAAS,IAAI,OAAO,GAAG,SAAS,EAAE,IAAI,OAAO,IAAI,MAAM,IAAI,MAAM;QACzE,IAAI,CAAC,OAAO,QAAQ,CAAC,GAAG,GAAG,KAAK,GAAG,GAAG,IAAI,GAAG,MAAM,IAAI,MAAM;QAC7D,IAAI,CAAC,OAAO,QAAQ,CAAC,GAAG,SAAS,KAAK,GAAG,SAAS,GAAG,GAAG,MAAM,IAAI,MAAM;QAExE,MAAM,WAAW,KAAK,KAAK,CAAC,GAAG,SAAS,GAAG,GAAG,GAAG;QACjD,uDAAuD;QACvD,IAAI,CAAC,OAAO,QAAQ,CAAC,GAAG,QAAQ,KAAK,GAAG,QAAQ,KAAK,UAAU;YAC7D,GAAG,QAAQ,GAAG;QAChB;IACF;IAEA;;;;GAIC,GACD,OAAO,aAAa,MAAM,CAAC,CAAC,EAAE;QAC5B,MAAM,IAAI,OAAO,OAAO,IAAI,QAAQ,KAAK,aAAa,IAAI,QAAQ,KAAK,OAAO,CAAC;QAC/E,OAAO,IAAI,YAAY;YACrB,KAAK,EAAE,GAAG;YACV,UAAU,EAAE,QAAQ,IAAI,CAAC;YACzB,OAAO,CAAC,EAAE,KAAK,IAAI,EAAE,EAAE,GAAG,CAAC,CAAA,IAAK,CAAC;oBAC/B,WAAW,EAAE,SAAS;oBACtB,MAAM,EAAE,IAAI;oBACZ,WAAW,EAAE,SAAS;oBACtB,KAAK,aAAa,EAAE,GAAG,EAAE;oBACzB,WAAW,aAAa,EAAE,SAAS,EAAE;oBACrC,UAAU,aAAa,EAAE,QAAQ,EAAE;gBACrC,CAAC;YACD,UAAU,aAAa,EAAE,QAAQ,EAAE;YACnC,UAAU,aAAa,EAAE,QAAQ,EAAE;YACnC,KAAK,aAAa,EAAE,GAAG,EAAE;YACzB,UAAU,aAAa,EAAE,QAAQ,EAAE;YACnC,OAAO,aAAa,EAAE,KAAK,EAAE;YAC7B,QAAQ,EAAE,MAAM,IAAI;YACpB,WAAW,EAAE,SAAS;YACtB,WAAW,EAAE,SAAS;YACtB,QAAQ,EAAE,MAAM;YAChB,MAAM,EAAE,IAAI;YACZ,UAAU,EAAE,QAAQ,IAAI;YACxB,SAAS,EAAE,OAAO;YAClB,aAAa,EAAE,WAAW;QAC5B;IACF;IAEA;;;;;GAKC,GACD,OAAO,SAAS,UAAU,CAAC,CAAC,EAAE;QAC5B,IAAI,CAAC,SAAS,MAAM,IAAI,MAAM;QAC9B,IAAI,CAAC,QAAQ,QAAQ,IAAI,CAAC,OAAO,QAAQ,QAAQ,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,MAAM,IAAI,MAAM;QACtF,IAAI,CAAC,MAAM,OAAO,CAAC,QAAQ,KAAK,KAAK,QAAQ,KAAK,CAAC,MAAM,KAAK,GAAG,MAAM,IAAI,MAAM;QAEjF,KAAK,MAAM,MAAM,QAAQ,KAAK,CAAE;YAC9B,MAAM,IAAI,YAAY,cAAc,CAAC;YACrC,YAAY,aAAa,CAAC;QAC5B;QACA,OAAO;IACT;IAEA;;;;;GAKC,GACD,gBAAgB,EAAE,2BAA2B,IAAI,EAAE,GAAG,CAAC,CAAC,EAAE;QACxD,IAAI,CAAC,MAAM,OAAO,CAAC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,GAAG,EAAE;QAC/C,IAAI,WAAW;QACf,KAAK,MAAM,MAAM,IAAI,CAAC,KAAK,CAAE;YAC3B,IAAI,0BAA0B;gBAC5B,GAAG,QAAQ,GAAG,KAAK,KAAK,CAAC,aAAa,GAAG,SAAS,EAAE,KAAK,aAAa,GAAG,GAAG,EAAE;YAChF;YACA,YAAY,aAAa,GAAG,QAAQ,EAAE;QACxC;QACA,IAAI,CAAC,QAAQ,GAAG,KAAK,KAAK,CAAC;QAC3B,6FAA6F;QAC7F,IAAI,CAAC,KAAK,GAAG,KAAK,GAAG,CAAC,GAAG,IAAI,CAAC,QAAQ,GAAG,aAAa,IAAI,CAAC,QAAQ,EAAE,KAAK,aAAa,IAAI,CAAC,GAAG,EAAE,KAAK,aAAa,IAAI,CAAC,QAAQ,EAAE;QAClI,OAAO;YAAE,UAAU,IAAI,CAAC,QAAQ;YAAE,OAAO,IAAI,CAAC,KAAK;QAAC;IACtD;IAEA;;;;GAIC,GACD,QAAQ,OAAO,CAAC,CAAC,EAAE;QACjB,MAAM,KAAK,YAAY,cAAc,CAAC;QACtC,YAAY,aAAa,CAAC;QAE1B,MAAM,MAAM,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAA,IAAK,OAAO,EAAE,SAAS,MAAM,OAAO,GAAG,SAAS,KAAK,OAAO,EAAE,SAAS,MAAM,OAAO,GAAG,SAAS;QACjI,IAAI,QAAQ,CAAC,GAAG;YACd,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;QAClB,OAAO;YACL,mCAAmC;YACnC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,GAAG,KAAK,KAAK,CAAC,aAAa,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,EAAE,KAAK,GAAG,GAAG;YAC9E,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,GAAG,aAAa,GAAG,SAAS,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS;YAChF,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,GAAG,KAAK,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG;QACvF;QACA,IAAI,CAAC,eAAe;IACtB;IAEA;;;;;GAKC,GACD,WAAW,SAAS,EAAE,SAAS,EAAE;QAC/B,MAAM,UAAU,IAAI,CAAC,KAAK,CAAC,MAAM;QACjC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAA,IAAK,CAAC,CAAC,OAAO,EAAE,SAAS,MAAM,OAAO,cAAc,OAAO,EAAE,SAAS,MAAM,OAAO,UAAU;QAC5H,MAAM,UAAU,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG;QACpC,IAAI,SAAS,IAAI,CAAC,eAAe;QACjC,OAAO;IACT;IAEA;;;;;;GAMC,GACD,cAAc,SAAS,EAAE,SAAS,EAAE,GAAG,EAAE;QACvC,MAAM,MAAM,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAA,IAAK,OAAO,EAAE,SAAS,MAAM,OAAO,cAAc,OAAO,EAAE,SAAS,MAAM,OAAO;QAClH,IAAI,QAAQ,CAAC,GAAG,OAAO;QACvB,MAAM,IAAI,KAAK,KAAK,CAAC,aAAa,KAAK;QACvC,IAAI,KAAK,GAAG,OAAO;QACnB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,GAAG;QACtB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,GAAG,KAAK,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,GAAG;QAClE,IAAI,CAAC,eAAe;QACpB,OAAO;IACT;IAEA;;;;GAIC,GACD,gBAAgB,SAAS,EAAE;QACzB,IAAI,CAAC,WAAW,OAAO;QACvB,MAAM,MAAM,OAAO,IAAI,CAAC,MAAM,IAAI,IAAI,IAAI;QAC1C,IAAI,CAAC,YAAY,cAAc,CAAC,QAAQ,CAAC,YAAY,OAAO;QAC5D,MAAM,UAAU,YAAY,WAAW,CAAC,IAAI,IAAI,EAAE;QAClD,OAAO,QAAQ,QAAQ,CAAC;IAC1B;IAEA;;;GAGC,GACD,UAAU;QACR,OAAO;YAAC;YAAa;YAAa;SAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM;IACpE;IAEA;;;GAGC,GACD,oBAAoB;QAClB,IAAI,CAAC,IAAI,CAAC,WAAW,IAAI,OAAO,IAAI,CAAC,WAAW,KAAK,UAAU,IAAI,CAAC,WAAW,GAAG,CAAC;IACrF;IAEA;;;GAGC,GACD,gBAAgB;QACd,IAAI,CAAC,IAAI,CAAC,OAAO,IAAI,OAAO,IAAI,CAAC,OAAO,KAAK,UAAU,IAAI,CAAC,OAAO,GAAG,CAAC;IACzE;IAEA;;;GAGC,GACD,mBAAmB;QACjB,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,eAAe,OAAO;QAChD,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,SAAS,GAAG,IAAI;QACrB,OAAO;IACT;IAEA;;;;;;;;;GASC,GACD,cAAc,EAAE,OAAO,EAAE,cAAc,EAAE,SAAS,EAAE,GAAG,CAAC,CAAC,EAAE;QACzD,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,YAAY,OAAO;QAC7C,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,iBAAiB;QACtB,IAAI,YAAY,WAAW,IAAI,CAAC,WAAW,CAAC,OAAO,GAAG,OAAO;QAC7D,IAAI,mBAAmB,WAAW,IAAI,CAAC,WAAW,CAAC,cAAc,GAAG,OAAO;QAC3E,IAAI,CAAC,WAAW,CAAC,SAAS,GAAG,WAAW,cAAc,IAAI;QAC1D,IAAI,CAAC,SAAS,GAAG,IAAI;QACrB,OAAO;IACT;IAEA;;;;;GAKC,GACD,gBAAgB,EAAE,WAAW,EAAE,GAAG,CAAC,CAAC,EAAE;QACpC,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,cAAc,OAAO;QAC/C,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,iBAAiB;QACtB,IAAI,CAAC,WAAW,CAAC,WAAW,GAAG,WAAW,gBAAgB,IAAI;QAC9D,IAAI,CAAC,SAAS,GAAG,IAAI;QACrB,OAAO;IACT;IAEA;;;;;;GAMC,GACD,gBAAgB,EAAE,MAAM,EAAE,GAAG,CAAC,CAAC,EAAE;QAC/B,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,cAAc,OAAO;QAC/C,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,IAAI,CAAC;QAC1B,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,OAAO,MAAM,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,GAAG;YAC3D,IAAI,IAAI;YACR,QAAQ,SAAS,OAAO,UAAU;QACpC;QACA,IAAI,CAAC,SAAS,GAAG,IAAI;QACrB,OAAO;IACT;IAEA;;;;;;GAMC,GACD,eAAe,EAAE,aAAa,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;QACvC,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,aAAa,OAAO;QAC9C,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,aAAa;QAClB,IAAI,CAAC,OAAO,CAAC,UAAU,GAAG,OAAO,MAAM,CAAC,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,UAAU,IAAI,CAAC,GAAG;QAC3E,IAAI,CAAC,OAAO,CAAC,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,UAAU,IAAI,IAAI;QACzD,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,IAAI,CAAC;QAC1B,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG;YAAE,IAAI,IAAI;YAAQ,MAAM;QAAW;QACtD,IAAI,CAAC,SAAS,GAAG,IAAI;QACrB,OAAO;IACT;IAEA;;;GAGC,GACD,kBAAkB,cAAc,EAAE;QAChC,IAAI,CAAC,gBAAgB;QACrB,IAAI,CAAC,iBAAiB;QACtB,IAAI,CAAC,WAAW,CAAC,cAAc,GAAG,OAAO;QACzC,IAAI,CAAC,SAAS,GAAG,IAAI;IACvB;IAEA;;;;;;GAMC,GACD,QAAQ,SAAS,EAAE,KAAK,EAAE;QACxB,IAAI,CAAC,WAAW;QAChB,MAAM,QAAQ,OAAO,WAAW,KAAK,CAAC,KAAK,GAAG,CAAC,CAAA,IAAK,EAAE,IAAI,IAAI,MAAM,CAAC;QACrE,IAAI,MAAM,MAAM,KAAK,GAAG;QACxB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,IAAI,CAAC;QAC1B,IAAI,MAAM,IAAI,CAAC,IAAI;QACnB,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,GAAG,GAAG,IAAK;YACzC,MAAM,IAAI,KAAK,CAAC,EAAE;YAClB,IAAI,CAAC,GAAG,CAAC,EAAE,IAAI,OAAO,GAAG,CAAC,EAAE,KAAK,UAAU,GAAG,CAAC,EAAE,GAAG,CAAC;YACrD,MAAM,GAAG,CAAC,EAAE;QACd;QACA,GAAG,CAAC,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE,CAAC,GAAG;QAC/B,IAAI,CAAC,SAAS,GAAG,IAAI;IACvB;IAEA;;;;;GAKC,GACD,SAAS,EAAE,SAAS,KAAK,EAAE,GAAG,CAAC,CAAC,EAAE;QAChC,MAAM,MAAM;YACV,UAAU;gBACR,MAAM,IAAI,CAAC,QAAQ,CAAC,IAAI;gBACxB,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK;gBAC1B,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK;gBAC1B,SAAS,IAAI,CAAC,QAAQ,CAAC,OAAO;YAChC;YACA,OAAO,MAAM,OAAO,CAAC,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA,KAAM,CAAC;oBACvD,WAAW,GAAG,SAAS;oBACvB,MAAM,GAAG,IAAI;oBACb,WAAW,GAAG,SAAS;oBACvB,KAAK,KAAK,KAAK,CAAC,aAAa,GAAG,GAAG,EAAE;oBACrC,WAAW,KAAK,KAAK,CAAC,aAAa,GAAG,SAAS,EAAE;oBACjD,UAAU,KAAK,KAAK,CAAC,aAAa,GAAG,QAAQ,EAAE;gBACjD,CAAC,KAAK,EAAE;YACR,UAAU,KAAK,KAAK,CAAC,aAAa,IAAI,CAAC,QAAQ,EAAE;YACjD,UAAU,KAAK,KAAK,CAAC,aAAa,IAAI,CAAC,QAAQ,EAAE;YACjD,KAAK,KAAK,KAAK,CAAC,aAAa,IAAI,CAAC,GAAG,EAAE;YACvC,UAAU,KAAK,KAAK,CAAC,aAAa,IAAI,CAAC,QAAQ,EAAE;YACjD,OAAO,KAAK,KAAK,CAAC,aAAa,IAAI,CAAC,KAAK,EAAE;YAC3C,QAAQ,IAAI,CAAC,MAAM,IAAI;YACvB,QAAQ,IAAI,CAAC,MAAM;YACnB,MAAM,IAAI,CAAC,IAAI;YACf,UAAU,QAAQ,IAAI,CAAC,QAAQ;YAC/B,SAAS,IAAI,CAAC,OAAO;YACrB,aAAa,IAAI,CAAC,WAAW;QAC/B;QAEA,IAAI,CAAC,UAAU,IAAI,CAAC,GAAG,KAAK,WAAW,IAAI,GAAG,GAAG,IAAI,CAAC,GAAG;QACzD,IAAI,IAAI,CAAC,SAAS,EAAE,IAAI,SAAS,GAAG,IAAI,CAAC,SAAS;QAClD,IAAI,IAAI,CAAC,SAAS,EAAE,IAAI,SAAS,GAAG,IAAI,CAAC,SAAS;QAClD,OAAO;IACT;IAEA;;;;GAIC,GACD,SAAS;QACP,MAAM,IAAI,IAAI,CAAC,QAAQ,CAAC;YAAE,QAAQ;QAAM;QACxC,IAAI,EAAE,GAAG,KAAK,aAAa,CAAC,OAAO,EAAE,GAAG,KAAK,YAAY,OAAO,EAAE,GAAG,KAAK,QAAQ,GAAG;YACnF,EAAE,EAAE,GAAG,OAAO,EAAE,GAAG;QACrB;QACA,OAAO;IACT;IAEA;;;GAGC,GACD,QAAQ;QACN,OAAO,YAAY,YAAY,CAAC,KAAK,KAAK,CAAC,KAAK,SAAS,CAAC,IAAI,CAAC,QAAQ;IACzE;AACF;uCAEe","debugId":null}},
    {"offset": {"line": 1090, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/untitled%20folder/src/services/orderService.js"],"sourcesContent":["// src/services/orderService.js\nimport mongoose from \"mongoose\";\nimport Order from \"models/orderModel.js\";\nimport Product from \"models/productModel.js\";\nimport InventoryService, { InsufficientStockError as InvInsufficientStockError } from \"./inventory.js\";\nimport DomainOrder from \"domain/orders.js\";\n\n/**\n * @file OrderService\n * @brief Order creation and lifecycle helpers (get, list, status updates, refunds).\n *\n * This service coordinates with InventoryService for stock changes and uses\n * mongoose transactions to ensure atomic operations when modifying inventory\n * and orders together.\n */\n\n/** Base order error */\nclass OrderError extends Error {}\n/** Thrown when stock cannot be satisfied during create/update */\nclass InsufficientStockError extends OrderError {}\n/** Thrown when invalid input supplied */\nclass InvalidOrderParamsError extends OrderError {}\n\nexport default class OrderService {\n  /**\n   * Create an order atomically: validates items, decrements stock, and saves order doc.\n   * (Original behaviour preserved.)\n   *\n   * @param {Object} customer - { name, email, phone, address }\n   * @param {Array<{productId, sizeLabel, qty}>} items\n   * @returns {Promise<Object>} saved Mongoose Order document\n   * @throws {OrderError|InsufficientStockError|Error}\n   */\n  static async createOrder(customer = {}, items = []) {\n    if (!Array.isArray(items) || items.length === 0) {\n      throw new OrderError(\"Order must contain at least one item\");\n    }\n\n    const session = await mongoose.startSession();\n    try {\n      session.startTransaction();\n\n      // 1) Load product docs for all requested items (inside session)\n      const productIds = [...new Set(items.map(i => String(i.productId)))];\n      const products = await Product.find({ _id: { $in: productIds } }).session(session).lean();\n      const productMap = new Map(products.map(p => [String(p._id), p]));\n\n      // 2) Build order items with snapshots and validation\n      const orderItems = [];\n      for (const it of items) {\n        const pid = String(it.productId);\n        const doc = productMap.get(pid);\n        if (!doc) {\n          throw new OrderError(`Product not found: ${pid}`);\n        }\n\n        const qty = Math.max(0, Math.floor(Number(it.qty || 0)));\n        if (qty <= 0) throw new OrderError(`Invalid quantity for product ${pid}`);\n\n        const size = Array.isArray(doc.sizes) ? doc.sizes.find(s => s.label === it.sizeLabel) : null;\n        if (!size) throw new OrderError(`Size '${it.sizeLabel}' not found for product ${pid}`);\n\n        const unitPrice = Number(doc.price || 0);\n        const subtotal = unitPrice * qty;\n\n        orderItems.push({\n          productId: doc._id,\n          name: doc.name,\n          sizeLabel: it.sizeLabel,\n          qty,\n          unitPrice,\n          subtotal\n        });\n      }\n\n      // 3) Attempt multi-item atomic stock decrement using InventoryService (throws on insufficient)\n      const inventoryItems = items.map(i => ({ productId: i.productId, sizeLabel: i.sizeLabel, qty: i.qty }));\n      await InventoryService.decreaseStockForItems(inventoryItems, session);\n\n      // 4) Calculate totals\n      const subtotal = orderItems.reduce((s, it) => s + (it.subtotal || 0), 0);\n      const shipping = 0;\n      const tax = 0;\n      const discount = 0;\n      const total = subtotal + shipping + tax - discount;\n\n      // 5) Create order doc (inside same transaction)\n      const orderDoc = new Order({\n        customer,\n        items: orderItems,\n        subtotal,\n        shipping,\n        tax,\n        discount,\n        total,\n        status: \"created\"\n      });\n\n      const saved = await orderDoc.save({ session });\n\n      await session.commitTransaction();\n      session.endSession();\n\n      return saved;\n    } catch (err) {\n      try {\n        await session.abortTransaction();\n      } catch (_) {}\n      session.endSession();\n\n      // Map inventory error to domain-level InsufficientStockError\n      if (err && (err.name === \"InsufficientStockError\" || err instanceof InvInsufficientStockError)) {\n        throw new InsufficientStockError(err.message);\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * List orders with optional userId filter and pagination.\n   * @param {Object} opts\n   * @param {String} [opts.userId]\n   * @param {number} [opts.page=1]\n   * @param {number} [opts.limit=20]\n   * @returns {Promise<{items:Object[], total:number, page:number, limit:number}>}\n   */\n  static async listOrders({ userId, page = 1, limit = 20 } = {}) {\n    const filter = {};\n    if (userId) filter.userId = userId;\n    const skip = Math.max(0, (Number(page) - 1) * Number(limit));\n    const items = await Order.find(filter).sort({ createdAt: -1 }).skip(skip).limit(Number(limit)).lean();\n    const total = await Order.countDocuments(filter);\n    return { items, total, page: Number(page), limit: Number(limit) };\n  }\n\n  /**\n   * Get a single order by id.\n   * @param {String} id - Order ObjectId/string\n   * @returns {Promise<Object|null>}\n   */\n  static async getById(id) {\n    if (!id) throw new InvalidOrderParamsError(\"Order id is required\");\n    const doc = await Order.findById(id).lean();\n    return doc || null;\n  }\n\n  /**\n   * Internal helper: restore stock for an order's items inside a session.\n   * If a product size doesn't exist, it will be created with the restored qty.\n   *\n   * @private\n   * @param {Object[]} items - order items array (having productId, sizeLabel, qty)\n   * @param {mongoose.ClientSession} session\n   */\n  static async _restoreStockForItems(items = [], session) {\n    if (!Array.isArray(items) || items.length === 0) return;\n    if (!session) throw new InvalidOrderParamsError(\"A mongoose session is required for restore\");\n\n    // For each item: attempt increaseStock; if increaseStock returns false (size missing) use addOrCreateSize then increaseStock\n    for (const it of items) {\n      const productId = it.productId;\n      const sizeLabel = it.sizeLabel;\n      const qty = it.qty;\n\n      // attempt to increase (if size exists)\n      const increased = await InventoryService.increaseStock(productId, sizeLabel, qty, session);\n      if (!increased) {\n        // ensure size exists and set stock (preserve existing behavior)\n        await InventoryService.addOrCreateSize(productId, sizeLabel, qty, session);\n      }\n    }\n  }\n\n  /**\n   * Update the status of an order. Optionally restore stock when transitioning to cancelled/refunded.\n   *\n   * Common lifecycle transitions:\n   *  - created -> processing -> shipped -> delivered\n   *  - any -> cancelled (may restore stock if requested)\n   *  - any -> refunded (restore stock if requested)\n   *\n   * @param {String} id - order id\n   * @param {String} newStatus - one of orderSchema enum statuses\n   * @param {Object} [opts]\n   * @param {Boolean} [opts.restoreStock=false] - when true and transitioning to cancelled/refunded, restores stock\n   * @returns {Promise<Object>} updated order document\n   * @throws {OrderError|InsufficientStockError|Error}\n   */\n  static async updateStatus(id, newStatus, { restoreStock = false } = {}) {\n    if (!id) throw new InvalidOrderParamsError(\"Order id is required\");\n    if (!newStatus || typeof newStatus !== \"string\") throw new InvalidOrderParamsError(\"newStatus is required\");\n\n    const VALID_STATUSES = [\"created\",\"pending\",\"paid\",\"processing\",\"shipped\",\"delivered\",\"cancelled\",\"refunded\"];\n    if (!VALID_STATUSES.includes(newStatus)) {\n      throw new InvalidOrderParamsError(`Invalid status: ${newStatus}`);\n    }\n\n    const session = await mongoose.startSession();\n    try {\n      session.startTransaction();\n\n      const order = await Order.findById(id).session(session);\n      if (!order) throw new OrderError(\"Order not found\");\n\n      const prevStatus = order.status;\n\n      // If the caller wants to restore stock when moving to cancelled/refunded and\n      // stock has previously been decremented (we assume stock was decremented on create),\n      // then restore now.\n      const shouldRestore = restoreStock && (newStatus === \"cancelled\" || newStatus === \"refunded\");\n\n      if (shouldRestore) {\n        // restore stock for items\n        await OrderService._restoreStockForItems(order.items, session);\n      }\n\n      // set status and update fulfillment timestamps where relevant\n      order.status = newStatus;\n\n      if (newStatus === \"shipped\") {\n        order.fulfillment = order.fulfillment || {};\n        order.fulfillment.shippedAt = order.fulfillment.shippedAt || new Date();\n      } else if (newStatus === \"delivered\") {\n        order.fulfillment = order.fulfillment || {};\n        order.fulfillment.deliveredAt = order.fulfillment.deliveredAt || new Date();\n      } else if (newStatus === \"cancelled\") {\n        // nothing else by default\n      } else if (newStatus === \"refunded\") {\n        order.payment = order.payment || {};\n        order.payment.refundedAt = order.payment.refundedAt || new Date();\n      }\n\n      // Save\n      const saved = await order.save({ session });\n\n      await session.commitTransaction();\n      session.endSession();\n\n      return saved;\n    } catch (err) {\n      try {\n        await session.abortTransaction();\n      } catch (_) {}\n      session.endSession();\n\n      // map inventory error to order-level InsufficientStockError\n      if (err && (err.name === \"InsufficientStockError\" || err instanceof InvInsufficientStockError)) {\n        throw new InsufficientStockError(err.message);\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Process a refund for an order id.\n   *\n   * Behavior:\n   *  - marks order.status = 'refunded'\n   *  - optionally restores stock (default true)\n   *  - optionally records refund metadata in order.meta.refund\n   *\n   * NOTE: actual payment-provider refund must be orchestrated outside or before calling this,\n   * this method only reflects refund in DB and inventory.\n   *\n   * @param {String} id - order id\n   * @param {Object} [opts]\n   * @param {Boolean} [opts.restoreStock=true]\n   * @param {Object} [opts.refundInfo] - arbitrary refund metadata (provider, refundId, amount, note)\n   * @returns {Promise<Object>} updated order document\n   * @throws {OrderError|InsufficientStockError|Error}\n   */\n  static async refundOrder(id, { restoreStock = true, refundInfo = {} } = {}) {\n    if (!id) throw new InvalidOrderParamsError(\"Order id is required\");\n\n    const session = await mongoose.startSession();\n    try {\n      session.startTransaction();\n\n      const order = await Order.findById(id).session(session);\n      if (!order) throw new OrderError(\"Order not found\");\n\n      if (order.status === \"refunded\") {\n        // already refunded; nothing to do\n        await session.commitTransaction();\n        session.endSession();\n        return order;\n      }\n\n      // Restore stock before marking refunded (so consumers won't see refunded order with missing stock)\n      if (restoreStock) {\n        await OrderService._restoreStockForItems(order.items, session);\n      }\n\n      // Mark payment/refund metadata and status\n      order.status = \"refunded\";\n      order.payment = order.payment || {};\n      order.payment.refundInfo = Object.assign({}, order.payment.refundInfo || {}, refundInfo);\n      order.payment.refundedAt = order.payment.refundedAt || new Date();\n\n      // also keep refund trace in meta\n      order.meta = order.meta || {};\n      order.meta.refund = { at: new Date(), info: refundInfo };\n\n      const saved = await order.save({ session });\n\n      await session.commitTransaction();\n      session.endSession();\n\n      return saved;\n    } catch (err) {\n      try {\n        await session.abortTransaction();\n      } catch (_) {}\n      session.endSession();\n\n      if (err && (err.name === \"InsufficientStockError\" || err instanceof InvInsufficientStockError)) {\n        throw new InsufficientStockError(err.message);\n      }\n      throw err;\n    }\n  }\n\n  // TODO: additional helpers such as `getOrdersByUser`, `archiveOrder`, `partialRefund`, etc.\n}\n\n// export error classes for callers\nexport { OrderError, InsufficientStockError, InvalidOrderParamsError };\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1417, "column": 0}, "map": {"version":3,"sources":["file:///Users/nischalreddymuthumula/Desktop/untitled%20folder/src/pages/api/orders/index.js"],"sourcesContent":["// src/pages/api/orders/index.js\nimport dbConnect from \"lib/dbConnect.js\";\nimport OrderService from \"services/orderService.js\";\n\n/**\n * API Handler: /api/orders\n *\n * POST -> create order\n * GET  -> list orders (query: page, limit)\n *\n * Errors:\n *  - 400 for validation\n *  - 409 for insufficient stock\n *  - 500 for server/db errors\n */\nexport default async function handler(req, res) {\n  try {\n    await dbConnect();\n  } catch (err) {\n    console.error(\"DB connect failed:\", err);\n    return res.status(500).json({ error: \"Database connection failed\" });\n  }\n\n  if (req.method === \"POST\") {\n    try {\n      const { customer, items } = req.body;\n\n      if (!Array.isArray(items) || items.length === 0) {\n        return res.status(400).json({ error: \"items array is required\" });\n      }\n      if (!customer || !customer.name) {\n        return res.status(400).json({ error: \"customer.name is required\" });\n      }\n\n      const created = await OrderService.createOrder(customer, items);\n      return res.status(201).json(created);\n    } catch (err) {\n      console.error(\"POST /api/orders error:\", err);\n      if (err.name === \"InsufficientStockError\") {\n        return res.status(409).json({ error: err.message });\n      }\n      if (err.name === \"OrderError\") {\n        return res.status(400).json({ error: err.message });\n      }\n      return res.status(500).json({ error: err.message || \"Failed to create order\" });\n    }\n  }\n\n  if (req.method === \"GET\") {\n    try {\n      const { page = \"1\", limit = \"20\" } = req.query;\n      const result = await OrderService.listOrders({ page: Number(page), limit: Number(limit) });\n      return res.status(200).json(result);\n    } catch (err) {\n      console.error(\"GET /api/orders error:\", err);\n      return res.status(500).json({ error: \"Failed to list orders\" });\n    }\n  }\n\n  res.setHeader(\"Allow\", [\"GET\", \"POST\"]);\n  return res.status(405).end(`Method ${req.method} Not Allowed`);\n}\n"],"names":[],"mappings":"AAAA,gCAAgC;;;;;AAChC;AACA;;;AAae,eAAe,QAAQ,GAAG,EAAE,GAAG;IAC5C,IAAI;QACF,MAAM,IAAA,2HAAS;IACjB,EAAE,OAAO,KAAK;QACZ,QAAQ,KAAK,CAAC,sBAAsB;QACpC,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,OAAO;QAA6B;IACpE;IAEA,IAAI,IAAI,MAAM,KAAK,QAAQ;QACzB,IAAI;YACF,MAAM,EAAE,QAAQ,EAAE,KAAK,EAAE,GAAG,IAAI,IAAI;YAEpC,IAAI,CAAC,MAAM,OAAO,CAAC,UAAU,MAAM,MAAM,KAAK,GAAG;gBAC/C,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;oBAAE,OAAO;gBAA0B;YACjE;YACA,IAAI,CAAC,YAAY,CAAC,SAAS,IAAI,EAAE;gBAC/B,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;oBAAE,OAAO;gBAA4B;YACnE;YAEA,MAAM,UAAU,MAAM,mIAAY,CAAC,WAAW,CAAC,UAAU;YACzD,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;QAC9B,EAAE,OAAO,KAAK;YACZ,QAAQ,KAAK,CAAC,2BAA2B;YACzC,IAAI,IAAI,IAAI,KAAK,0BAA0B;gBACzC,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;oBAAE,OAAO,IAAI,OAAO;gBAAC;YACnD;YACA,IAAI,IAAI,IAAI,KAAK,cAAc;gBAC7B,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;oBAAE,OAAO,IAAI,OAAO;gBAAC;YACnD;YACA,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,OAAO,IAAI,OAAO,IAAI;YAAyB;QAC/E;IACF;IAEA,IAAI,IAAI,MAAM,KAAK,OAAO;QACxB,IAAI;YACF,MAAM,EAAE,OAAO,GAAG,EAAE,QAAQ,IAAI,EAAE,GAAG,IAAI,KAAK;YAC9C,MAAM,SAAS,MAAM,mIAAY,CAAC,UAAU,CAAC;gBAAE,MAAM,OAAO;gBAAO,OAAO,OAAO;YAAO;YACxF,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;QAC9B,EAAE,OAAO,KAAK;YACZ,QAAQ,KAAK,CAAC,0BAA0B;YACxC,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,OAAO;YAAwB;QAC/D;IACF;IAEA,IAAI,SAAS,CAAC,SAAS;QAAC;QAAO;KAAO;IACtC,OAAO,IAAI,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC,OAAO,EAAE,IAAI,MAAM,CAAC,YAAY,CAAC;AAC/D","debugId":null}}]
}